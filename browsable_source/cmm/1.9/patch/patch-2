diff -c /home/omega/attardi/posso/cmm/ChangeLog /project/posso/cmm/curr/cmm/ChangeLog
*** /home/omega/attardi/posso/cmm/ChangeLog	Thu Sep 25 16:27:38 1997
--- /project/posso/cmm/curr/cmm/ChangeLog	Mon Sep 22 10:20:26 1997
***************
*** 1,19 ****
- Thu Sep 25 16:03:39 1997  Giuseppe Attardi  <attardi@omega>
- 
- 	* test1.cpp (listtest2): reduced to 100 iterations
- 
- 	* msw.cpp (mswMarkRegisteredRoots): added. Was reason for bug
- 	in mac-rad-split.xcl with MSW.
- 
- 	* cmm.h: moved declaration of RootArea and RootAreas from cmm.cpp
- 	for use by msw.cpp
- 
- Wed Sep 24 13:42:12 1997  Giuseppe Attardi  <attardi@omega>
- 
- 	* Released version 1.9a
- 
- 	* msw.cpp (mswRealloc): added fix by Iglio for bug in cassou
- 
  Mon Sep 22 10:19:21 1997  Giuseppe Attardi  <attardi@omega>
  
  	* Makefile (test): renamed test5 to test1
--- 1,3 ----
Only in /home/omega/attardi/posso/cmm: Parallel
diff -c /home/omega/attardi/posso/cmm/cmm.cpp /project/posso/cmm/curr/cmm/cmm.cpp
*** /home/omega/attardi/posso/cmm/cmm.cpp	Thu Sep 25 18:52:06 1997
--- /project/posso/cmm/curr/cmm/cmm.cpp	Wed Sep 24 11:24:44 1997
***************
*** 54,60 ****
  
  /* Version tag */
  
! char*  Cmm::version = "CMM 1.9b";
  
  /*---------------------------------------------------------------------------*
   *
--- 54,60 ----
  
  /* Version tag */
  
! char*  Cmm::version = "CMM 1.9a";
  
  /*---------------------------------------------------------------------------*
   *
***************
*** 287,367 ****
   *
   *---------------------------------------------------------------------------*/
  
! RootAreas	roots;	// areas registered as containing roots
! 
! RootAreas::RootAreas()
  {
!   last = 0;
!   max = 0;
!   freed = 0;
!   entries = NULL;
! }
  
! void
! RootAreas::insert(void * addr, int bytes)
  {
! # define	    setIncrement 10
!   int i;
  
!   if (freed)
      {
        for (i = 0; i < last; i++)
! 	if (entries[i].addr == NULL)
  	  {
! 	    freed--;
! 	    break;
  	  }
      }
!   else
      {
!       if (last == max)
  	{
! 	  RootArea  *np;
! 	  max += setIncrement;
! 	  np = ::new RootArea[max];
! 	  for (i = 0; i < last; i++)
! 	    np[i] = entries[i];
! 	  // clear the rest
! 	  for (; i < max; i++)
! 	    np[i].addr = NULL;
! 	  if (entries) ::delete entries;
! 	  entries = np;
  	}
!       i = last++;
      }
-   entries[i].addr = (GCP)addr;
-   entries[i].bytes = bytes;
- }
  
! void
! RootAreas::erase(void* addr)
! {
!   for (int i = 0; i < last; i++)
!     if (entries[i].addr == addr)
!       {
! 	entries[i].addr = NULL;
! 	freed++;
! 	return;
!       }
! }
  
! void
! RootAreas::begin() { iter = 0; }
  
! RootArea*
! RootAreas::get()
! {
!   // look for a non empty entry
!   while (iter < last)
!     {
!       if (entries[iter].addr)
! 	return &entries[iter++];
!       else
! 	iter++;
!     }
!   // No more entries;
!   return (RootArea*)NULL;
! }
  
  /*---------------------------------------------------------------------------*
   * -- registerRootArea()
--- 287,382 ----
   *
   *---------------------------------------------------------------------------*/
  
! typedef struct
  {
!   GCP	     addr;		/* Address of the roots */
!   int  	     bytes;		/* Number of bytes in the roots */
! } RootArea;
  
! class RootAreas
  {
!  public:
!   RootAreas()
!     {
!       last = 0;
!       max = 0;
!       freed = 0;
!       entries = NULL;
!     }
! 
!   void insert(void * addr, int bytes)
!     {
! #     define	    setIncrement 10
!       int i;
! 
!       if (freed)
! 	{
! 	  for (i = 0; i < last; i++)
! 	    if (entries[i].addr == NULL)
! 	      {
! 		freed--;
! 		break;
! 	      }
! 	}
!       else
! 	{
! 	  if (last == max)
! 	    {
! 	      RootArea  *np;
! 	      max += setIncrement;
! 	      np = ::new RootArea[max];
! 	      for (i = 0; i < last; i++)
! 		np[i] = entries[i];
! 	      // clear the rest
! 	      for (; i < max; i++)
! 		np[i].addr = NULL;
! 	      if (entries) ::delete entries;
! 	      entries = np;
! 	    }
! 	  i = last++;
! 	}
!       entries[i].addr = (GCP)addr;
!       entries[i].bytes = bytes;
!     }
  
!   void erase(void* addr)
      {
+       int i;
+ 
        for (i = 0; i < last; i++)
! 	if (entries[i].addr == addr)
  	  {
! 	    entries[i].addr = NULL;
! 	    freed++;
! 	    return;
  	  }
      }
! 
!   RootArea* get()
      {
!       // look for a non empty entry
!       while (iter < last)
  	{
! 	  if (entries[iter].addr)
! 	    return &entries[iter++];
! 	  else
! 	    iter++;
  	}
!       // No more entries;
!       return (RootArea*)NULL;
      }
  
!   void begin() { iter = 0; }
  
! private:
!   RootArea*	entries;
!   int		last;
!   int		max;
!   int		freed;
!   int		iter;
! };
  
! static RootAreas	roots;	// areas registered as containing roots
  
  /*---------------------------------------------------------------------------*
   * -- registerRootArea()
***************
*** 396,402 ****
  environmentValue(char *name, int &value)
  {
    char* valuestring = getenv(name);
!   
    if (valuestring != NULL)
      {
        value = atoi(valuestring);
--- 411,417 ----
  environmentValue(char *name, int &value)
  {
    char* valuestring = getenv(name);
! 
    if (valuestring != NULL)
      {
        value = atoi(valuestring);
***************
*** 414,420 ****
  int
  CmmObject::words()
  {
!   
    register int length = 1;
    register int index = WORD_INDEX(this+1);
    int shift = BIT_INDEX(this+1);
--- 429,435 ----
  int
  CmmObject::words()
  {
! 
    register int length = 1;
    register int index = WORD_INDEX(this+1);
    int shift = BIT_INDEX(this+1);
***************
*** 424,430 ****
    nextPage += pageGroup[nextPage];
    int max = ((Word)pageToGCP(nextPage) - (Word)this)
      / (bitsPerWord * bytesPerWord);
!   
    do
      {
        do
--- 439,445 ----
    nextPage += pageGroup[nextPage];
    int max = ((Word)pageToGCP(nextPage) - (Word)this)
      / (bitsPerWord * bytesPerWord);
! 
    do
      {
        do
***************
*** 552,558 ****
   *---------------------------------------------------------------------------*/
  
  #ifdef CMM_ID
! /* with ID_INC=20000000, stats gets corrupted after 158 collections
     (in bjork70 on Solaris).
     Apparently the 40MB block is allocated at 0x2447b20-0x4a6d520, and heap
     expansion reaches 0x4b6d400 and incorporates it. Pages from here are
--- 567,573 ----
   *---------------------------------------------------------------------------*/
  
  #ifdef CMM_ID
! /* with ID_INC=20000000, stats gets corrupted after 158 collection
     (in bjork70 on Solaris).
     Apparently the 40MB block is allocated at 0x2447b20-0x4a6d520, and heap
     expansion reaches 0x4b6d400 and incorporates it. Pages from here are
***************
*** 575,598 ****
   *---------------------------------------------------------------------------*/
  
  #if !HEADER_SIZE || defined(MARKING)
! # define tableFraction (sizeof(Page) /* pageLink */\
! 			+ sizeof(CmmHeap**)	     /* pageHeap */\
! 			+ sizeof(short)*2	     /* pageSpace, pageGroup */\
  			+ wordsPerPage/bitsPerWord*bytesPerWord /* objectMap */\
  			+ wordsPerPage/bitsPerWord*bytesPerWord) /* liveMap */
  #else
! # define tableFraction (sizeof(Page) /* pageLink */\
! 			+ sizeof(CmmHeap**)		     /* pageHeap */\
! 			+ sizeof(short)*2		     /* pageSpace, pageGroup */\
  			+ wordsPerPage/bitsPerWord*bytesPerWord) /* objectMap */
  #endif
!      
!      void
!      CmmHeap::init()
  {
    char  *heap;
    Page  i;
!   
  #ifdef CMM_ID
    /*
     * create stats here so as not to interfere with heap.
--- 590,613 ----
   *---------------------------------------------------------------------------*/
  
  #if !HEADER_SIZE || defined(MARKING)
! # define tableFraction (sizeof(Page)           /* pageLink */\
! 			+ sizeof(CmmHeap**)    /* pageHeap */\
! 			+ sizeof(short)*2      /* pageSpace, pageGroup */\
  			+ wordsPerPage/bitsPerWord*bytesPerWord /* objectMap */\
  			+ wordsPerPage/bitsPerWord*bytesPerWord) /* liveMap */
  #else
! # define tableFraction (sizeof(Page)           /* pageLink */\
! 			+ sizeof(CmmHeap**)    /* pageHeap */\
! 			+ sizeof(short)*2      /* pageSpace, pageGroup */\
  			+ wordsPerPage/bitsPerWord*bytesPerWord) /* objectMap */
  #endif
! 
! void
! CmmHeap::init()
  {
    char  *heap;
    Page  i;
! 
  #ifdef CMM_ID
    /*
     * create stats here so as not to interfere with heap.
***************
*** 602,608 ****
    stats = ::new char[objectIDmax];
    bzero(stats, objectIDmax);
  #endif CMM_ID
!   
    /* Log actual heap parameters if from environment or logging */
    if ((environmentValue("CMM_MINHEAP", Cmm::minHeap)
         | environmentValue("CMM_MAXHEAP", Cmm::maxHeap)
--- 617,623 ----
    stats = ::new char[objectIDmax];
    bzero(stats, objectIDmax);
  #endif CMM_ID
! 
    /* Log actual heap parameters if from environment or logging */
    if ((environmentValue("CMM_MINHEAP", Cmm::minHeap)
         | environmentValue("CMM_MAXHEAP", Cmm::maxHeap)
***************
*** 616,626 ****
      fprintf(stderr, "***** Cmm(%d, %d, %d, %d, %d, %d, %d, %d)\n",
  	    Cmm::minHeap, Cmm::maxHeap, Cmm::incHeap, Cmm::generational,
  	    Cmm::incPercent, Cmm::gcThreshold, Cmm::flags, Cmm::verbose);
!   
    /* Allocate heap and side tables.  Exit on allocation failure. */
    heapSpanPages = totalPages = (Cmm::minHeap + bytesPerPage - 1)/bytesPerPage;
    tablePages = (totalPages*tableFraction + bytesPerPage - 1) / bytesPerPage;
!   
    /* Allocate one block for both the heap and the tables.
     * The tables will be recycled into pages at the next collection.
     */
--- 631,641 ----
      fprintf(stderr, "***** Cmm(%d, %d, %d, %d, %d, %d, %d, %d)\n",
  	    Cmm::minHeap, Cmm::maxHeap, Cmm::incHeap, Cmm::generational,
  	    Cmm::incPercent, Cmm::gcThreshold, Cmm::flags, Cmm::verbose);
! 
    /* Allocate heap and side tables.  Exit on allocation failure. */
    heapSpanPages = totalPages = (Cmm::minHeap + bytesPerPage - 1)/bytesPerPage;
    tablePages = (totalPages*tableFraction + bytesPerPage - 1) / bytesPerPage;
! 
    /* Allocate one block for both the heap and the tables.
     * The tables will be recycled into pages at the next collection.
     */
***************
*** 641,647 ****
    lastHeapPage = firstHeapPage + heapSpanPages - 1;
    firstTablePage = lastHeapPage + 1;
    freePages = totalPages;
!   
    pageSpace = (short *)pageToGCP(firstTablePage);
    pageGroup = &pageSpace[totalPages];
    pageLink = (Page *)&pageGroup[totalPages];
--- 656,662 ----
    lastHeapPage = firstHeapPage + heapSpanPages - 1;
    firstTablePage = lastHeapPage + 1;
    freePages = totalPages;
! 
    pageSpace = (short *)pageToGCP(firstTablePage);
    pageGroup = &pageSpace[totalPages];
    pageLink = (Page *)&pageGroup[totalPages];
***************
*** 650,663 ****
  # if !HEADER_SIZE || defined(MARKING)
    liveMap = (Word *)&objectMap[totalPages*wordsPerPage/bitsPerWord];
  # endif
!   
    /* The following definitions are safe because these vectors are accessed
       only through an address within a page. Instead of using
       pageSpace[addr - firstHeapPage]
       space is displaced by firstHeapPage so that we can use:
       pageSpace[addr]
       */
!   
    pageSpace = pageSpace - firstHeapPage;
    pageLink = pageLink - firstHeapPage;
    pageGroup  = pageGroup  - firstHeapPage;
--- 665,678 ----
  # if !HEADER_SIZE || defined(MARKING)
    liveMap = (Word *)&objectMap[totalPages*wordsPerPage/bitsPerWord];
  # endif
! 
    /* The following definitions are safe because these vectors are accessed
       only through an address within a page. Instead of using
       pageSpace[addr - firstHeapPage]
       space is displaced by firstHeapPage so that we can use:
       pageSpace[addr]
       */
! 
    pageSpace = pageSpace - firstHeapPage;
    pageLink = pageLink - firstHeapPage;
    pageGroup  = pageGroup  - firstHeapPage;
***************
*** 666,672 ****
  # if !HEADER_SIZE || defined(MARKING)
    liveMap = liveMap - WORD_INDEX(firstHeapPage*bytesPerPage);
  # endif
!   
    /* Initialize tables */
    for (i = firstHeapPage ; i <= lastHeapPage ; i++)
      pageHeap[i] = NOHEAP;
--- 681,687 ----
  # if !HEADER_SIZE || defined(MARKING)
    liveMap = liveMap - WORD_INDEX(firstHeapPage*bytesPerPage);
  # endif
! 
    /* Initialize tables */
    for (i = firstHeapPage ; i <= lastHeapPage ; i++)
      pageHeap[i] = NOHEAP;
***************
*** 675,697 ****
    firstFreePage = firstHeapPage;
    queueHead = 0;
    Cmm::created = true;
!   
    Cmm::theDefaultHeap->usedPages 	= 0;
    Cmm::theDefaultHeap->stablePages 	= 0;
    Cmm::theDefaultHeap->firstUnusedPage	= firstHeapPage;
    Cmm::theDefaultHeap->firstReservedPage= firstHeapPage;
    Cmm::theDefaultHeap->lastReservedPage = firstHeapPage;
!   
  # if !HEADER_SIZE
    aGcFreeObject = ::new GcFreeObject;
  #   ifdef DOUBLE_ALIGN_OPTIMIZE
    aGcPadObject = ::new GcPadObject;
  #   endif
  # endif
!   
    // The following initializations are needed by the CmmObject::new
    // operator. For this reason they don't use new, but ::new.
!   
    aCmmObject = ::new CmmObject;
    aCmmVarObject = ::new CmmVarObject;
  }
--- 690,712 ----
    firstFreePage = firstHeapPage;
    queueHead = 0;
    Cmm::created = true;
! 
    Cmm::theDefaultHeap->usedPages 	= 0;
    Cmm::theDefaultHeap->stablePages 	= 0;
    Cmm::theDefaultHeap->firstUnusedPage	= firstHeapPage;
    Cmm::theDefaultHeap->firstReservedPage= firstHeapPage;
    Cmm::theDefaultHeap->lastReservedPage = firstHeapPage;
! 
  # if !HEADER_SIZE
    aGcFreeObject = ::new GcFreeObject;
  #   ifdef DOUBLE_ALIGN_OPTIMIZE
    aGcPadObject = ::new GcPadObject;
  #   endif
  # endif
! 
    // The following initializations are needed by the CmmObject::new
    // operator. For this reason they don't use new, but ::new.
! 
    aCmmObject = ::new CmmObject;
    aCmmVarObject = ::new CmmVarObject;
  }
***************
*** 750,785 ****
    Word  *new_liveMap;
  # endif
    Page  i;
!   
    short *new_pageSpace;
    short *new_pageGroup;
    CmmHeap **new_pageHeap;
!   
    char  *new_tables;
    int   new_tablePages;
    char  *inc_heap;
    bool recycleOldTables = true;
!   
    /* Check for previous expansion failure */
    if (expandFailed) return  0;
!   
    Page lastTablePage = firstTablePage + tablePages - 1;
!   
    /* Allocate additional heap and determine page span */
!   
  #ifndef _WIN32
    /* Save the current exception handler for ::new, so we can replace it
       with a dummy one in order to be notified of failure */
    savedNewHandler = set_new_handler(dummyNewHandler);
  #endif
!   
    inc_heap = ::new char[inc_totalPages*bytesPerPage + bytesPerPage - 1];
    if (inc_heap == NULL) goto fail;
    inc_heap = inc_heap + bytesPerPage - 1;
    inc_heap -= (Word)inc_heap % bytesPerPage;
    inc_firstHeapPage = GCPtoPage(inc_heap);
    inc_lastHeapPage = inc_firstHeapPage + inc_totalPages - 1;
!   
    new_firstHeapPage = MIN(firstHeapPage, inc_firstHeapPage);
    new_lastHeapPage = MAX(lastHeapPage, inc_lastHeapPage);
    /* Sometimes malloc() (e.g. on Linux ELF) allocates small blocks at
--- 765,800 ----
    Word  *new_liveMap;
  # endif
    Page  i;
! 
    short *new_pageSpace;
    short *new_pageGroup;
    CmmHeap **new_pageHeap;
! 
    char  *new_tables;
    int   new_tablePages;
    char  *inc_heap;
    bool recycleOldTables = true;
! 
    /* Check for previous expansion failure */
    if (expandFailed) return  0;
! 
    Page lastTablePage = firstTablePage + tablePages - 1;
! 
    /* Allocate additional heap and determine page span */
! 
  #ifndef _WIN32
    /* Save the current exception handler for ::new, so we can replace it
       with a dummy one in order to be notified of failure */
    savedNewHandler = set_new_handler(dummyNewHandler);
  #endif
! 
    inc_heap = ::new char[inc_totalPages*bytesPerPage + bytesPerPage - 1];
    if (inc_heap == NULL) goto fail;
    inc_heap = inc_heap + bytesPerPage - 1;
    inc_heap -= (Word)inc_heap % bytesPerPage;
    inc_firstHeapPage = GCPtoPage(inc_heap);
    inc_lastHeapPage = inc_firstHeapPage + inc_totalPages - 1;
! 
    new_firstHeapPage = MIN(firstHeapPage, inc_firstHeapPage);
    new_lastHeapPage = MAX(lastHeapPage, inc_lastHeapPage);
    /* Sometimes malloc() (e.g. on Linux ELF) allocates small blocks at
***************
*** 790,796 ****
    if (distant(lastHeapPage, firstTablePage)
        && distant(lastTablePage, firstHeapPage))
      recycleOldTables = false;
!   
    if (recycleOldTables)
      {
        new_firstHeapPage = MIN(new_firstHeapPage, firstTablePage);
--- 805,811 ----
    if (distant(lastHeapPage, firstTablePage)
        && distant(lastTablePage, firstHeapPage))
      recycleOldTables = false;
! 
    if (recycleOldTables)
      {
        new_firstHeapPage = MIN(new_firstHeapPage, firstTablePage);
***************
*** 799,805 ****
      }
    new_totalPages = totalPages + tablePages + inc_totalPages;
    heapSpanPages = new_lastHeapPage - new_firstHeapPage + 1;
!   
    new_tablePages = (heapSpanPages*tableFraction
  		    + bytesPerPage - 1) / bytesPerPage;
    new_tables = ::new char[new_tablePages*bytesPerPage + bytesPerPage - 1];
--- 814,820 ----
      }
    new_totalPages = totalPages + tablePages + inc_totalPages;
    heapSpanPages = new_lastHeapPage - new_firstHeapPage + 1;
! 
    new_tablePages = (heapSpanPages*tableFraction
  		    + bytesPerPage - 1) / bytesPerPage;
    new_tables = ::new char[new_tablePages*bytesPerPage + bytesPerPage - 1];
***************
*** 827,833 ****
    new_liveMap =
      (Word *)&new_objectMap[heapSpanPages*wordsPerPage/bitsPerWord];
  #endif
!   
    new_pageSpace = new_pageSpace - new_firstHeapPage;
    new_pageLink = new_pageLink - new_firstHeapPage;
    new_pageGroup = new_pageGroup - new_firstHeapPage;
--- 842,848 ----
    new_liveMap =
      (Word *)&new_objectMap[heapSpanPages*wordsPerPage/bitsPerWord];
  #endif
! 
    new_pageSpace = new_pageSpace - new_firstHeapPage;
    new_pageLink = new_pageLink - new_firstHeapPage;
    new_pageGroup = new_pageGroup - new_firstHeapPage;
***************
*** 836,842 ****
  #if !HEADER_SIZE || defined(MARKING)
    new_liveMap = new_liveMap - WORD_INDEX(new_firstHeapPage*bytesPerPage);
  #endif
!   
    /* Initialize new side tables */
    for (i = inc_firstHeapPage ; i <= inc_lastHeapPage ; i++)
      new_pageHeap[i] = NOHEAP;
--- 851,857 ----
  #if !HEADER_SIZE || defined(MARKING)
    new_liveMap = new_liveMap - WORD_INDEX(new_firstHeapPage*bytesPerPage);
  #endif
! 
    /* Initialize new side tables */
    for (i = inc_firstHeapPage ; i <= inc_lastHeapPage ; i++)
      new_pageHeap[i] = NOHEAP;
***************
*** 856,862 ****
        new_liveMap[i] = liveMap[i];
  #endif
      }
!   
    if (recycleOldTables)
      {
        /* Recycle old tables */
--- 871,877 ----
        new_liveMap[i] = liveMap[i];
  #endif
      }
! 
    if (recycleOldTables)
      {
        /* Recycle old tables */
***************
*** 865,874 ****
        /* Fill gaps */
        Page gapStart = MIN(lastTablePage, inc_lastHeapPage);
        Page gap1Start = MIN(lastHeapPage, gapStart);
!       
        Page gapEnd = MAX(firstTablePage, inc_firstHeapPage);
        Page gap2End = MAX(firstHeapPage, gapEnd);
!       
        Page gap1End = (gapEnd == gap2End) ?
  	MAX(firstHeapPage, MIN(firstTablePage, inc_firstHeapPage)) : gapEnd;
        Page gap2Start = (gapStart == gap1Start) ?
--- 880,889 ----
        /* Fill gaps */
        Page gapStart = MIN(lastTablePage, inc_lastHeapPage);
        Page gap1Start = MIN(lastHeapPage, gapStart);
! 
        Page gapEnd = MAX(firstTablePage, inc_firstHeapPage);
        Page gap2End = MAX(firstHeapPage, gapEnd);
! 
        Page gap1End = (gapEnd == gap2End) ?
  	MAX(firstHeapPage, MIN(firstTablePage, inc_firstHeapPage)) : gapEnd;
        Page gap2Start = (gapStart == gap1Start) ?
***************
*** 880,886 ****
      }
    else
      ::delete (char *)(pageSpace + firstHeapPage); // address of old tables
!   
    pageSpace = new_pageSpace;
    pageLink = new_pageLink;
    pageGroup = new_pageGroup;
--- 895,901 ----
      }
    else
      ::delete (char *)(pageSpace + firstHeapPage); // address of old tables
! 
    pageSpace = new_pageSpace;
    pageLink = new_pageLink;
    pageGroup = new_pageGroup;
***************
*** 896,902 ****
    tablePages = new_tablePages;
    firstTablePage = GCPtoPage(new_tables);
    firstFreePage = inc_firstHeapPage;
!   
    WHEN_VERBOSE (CMM_STATS,
  		fprintf(stderr,
  			"\n***** CMM  Heap expanded to %d bytes\n",
--- 911,917 ----
    tablePages = new_tablePages;
    firstTablePage = GCPtoPage(new_tables);
    firstFreePage = inc_firstHeapPage;
! 
    WHEN_VERBOSE (CMM_STATS,
  		fprintf(stderr,
  			"\n***** CMM  Heap expanded to %d bytes\n",
***************
*** 964,971 ****
  void
  promotePage(GCP cp)
  {
!   Word page = GCPtoPage(cp); // Word is needed for 64bit architectures
!   
    // Don't promote pages belonging to other heaps.
    // (We noticed no benefit by inlining the following test in the caller)
    if (page >= firstHeapPage
--- 979,986 ----
  void
  promotePage(GCP cp)
  {
!   Word page = GCPtoPage(cp);	// Word is needed for 64bit architectures
! 
    // Don't promote pages belonging to other heaps.
    // (We noticed no benefit by inlining the following test in the caller)
    if (page >= firstHeapPage
***************
*** 1009,1020 ****
  basePointer(GCP ip)
  {
    ip = (GCP)((Word)ip & ~(Word)(bytesPerWord-1));
!   
    register int index	= WORD_INDEX(ip);
    register int inner	= BIT_INDEX(ip);
    register Word mask	= 1L << inner;
    register Word bits	= objectMap[index];
!   
    do
      {
        do
--- 1024,1035 ----
  basePointer(GCP ip)
  {
    ip = (GCP)((Word)ip & ~(Word)(bytesPerWord-1));
! 
    register int index	= WORD_INDEX(ip);
    register int inner	= BIT_INDEX(ip);
    register Word mask	= 1L << inner;
    register Word bits	= objectMap[index];
! 
    do
      {
        do
***************
*** 1061,1075 ****
  #ifdef CMM_ID
    int ID;
  #endif
!   int  page = GCPtoPage(cp); /* Page number */
!   GCP  np;	     /* Pointer to the new object */
  # if HEADER_SIZE
!   Ptr  header;		/* Object header */
  # endif
!   
    /* Verify that the object is a valid pointer and decrement ptr cnt */
    WHEN_FLAGS (CMM_TSTOBJ, verifyObject(cp, true); verifyHeader(cp););
!   
    /* If cell is already forwarded, return forwarding pointer */
  # if HEADER_SIZE
    header = cp[-HEADER_SIZE];
--- 1076,1090 ----
  #ifdef CMM_ID
    int ID;
  #endif
!   int  page = GCPtoPage(cp);	/* Page number */
!   GCP  np;			/* Pointer to the new object */
  # if HEADER_SIZE
!   Ptr  header;			/* Object header */
  # endif
! 
    /* Verify that the object is a valid pointer and decrement ptr cnt */
    WHEN_FLAGS (CMM_TSTOBJ, verifyObject(cp, true); verifyHeader(cp););
! 
    /* If cell is already forwarded, return forwarding pointer */
  # if HEADER_SIZE
    header = cp[-HEADER_SIZE];
***************
*** 1085,1091 ****
    if (FORWARDED(cp))
      return ((GCP)*cp);
  # endif
!   
    /* Move or promote object */
  #if HEADER_SIZE
    register int  words = HEADER_WORDS(header);
--- 1100,1106 ----
    if (FORWARDED(cp))
      return ((GCP)*cp);
  # endif
! 
    /* Move or promote object */
  #if HEADER_SIZE
    register int  words = HEADER_WORDS(header);
***************
*** 1115,1121 ****
    /* Forward object, leave forwarding pointer in old object header */
    WHEN_VERBOSE (CMM_STATS, scavengeCount++;)
  # if HEADER_SIZE
!     *firstFreeWord++ = header;
  # else
    GCP ocp = cp;
  # endif
--- 1130,1136 ----
    /* Forward object, leave forwarding pointer in old object header */
    WHEN_VERBOSE (CMM_STATS, scavengeCount++;)
  # if HEADER_SIZE
!   *firstFreeWord++ = header;
  # else
    GCP ocp = cp;
  # endif
***************
*** 1123,1136 ****
    SET_OBJECTMAP(np);
    freeWords = freeWords - words;
  # if HEADER_SIZE
!   cp[-HEADER_SIZE] = (Ptr)np; // lowest bit 0 means forwarded
    words -= HEADER_SIZE;
    while (words--) *firstFreeWord++ = *cp++;
  #   ifdef HEADER_ALIGN
    HEADER_ALIGN(firstFreeWord, freeWords);
  #   endif
  # else
!   MARK(cp);		// Necessary to recognise as forwarded
    while (words--) *firstFreeWord++ = *cp++;
    *ocp = (Word)np;
  # endif				// !HEADER_SIZE
--- 1138,1151 ----
    SET_OBJECTMAP(np);
    freeWords = freeWords - words;
  # if HEADER_SIZE
!   cp[-HEADER_SIZE] = (Ptr)np;	// lowest bit 0 means forwarded
    words -= HEADER_SIZE;
    while (words--) *firstFreeWord++ = *cp++;
  #   ifdef HEADER_ALIGN
    HEADER_ALIGN(firstFreeWord, freeWords);
  #   endif
  # else
!   MARK(cp);			// Necessary to recognise as forwarded
    while (words--) *firstFreeWord++ = *cp++;
    *ocp = (Word)np;
  # endif				// !HEADER_SIZE
***************
*** 1174,1186 ****
  DefaultHeap::scavenge(CmmObject **loc)
  {
    GCP pp = (GCP)*loc;
!   Word page = GCPtoPage(pp); // Word needed for 64bit arch.
    if (!OUTSIDE_HEAPS(page))
      {
        GCP p = (GCP)basePointer((GCP)*loc);
        page = GCPtoPage(p);
!       
!       if (inside(p))	// in this heap
  	{
  	  if (inFromSpace(page)) // can be moved
  	    *loc = (CmmObject *)((Word)move(p) + (Word)*loc - (Word)p);
--- 1189,1201 ----
  DefaultHeap::scavenge(CmmObject **loc)
  {
    GCP pp = (GCP)*loc;
!   Word page = GCPtoPage(pp);	// Word needed for 64bit arch.
    if (!OUTSIDE_HEAPS(page))
      {
        GCP p = (GCP)basePointer((GCP)*loc);
        page = GCPtoPage(p);
! 
!       if (inside(p))		// in this heap
  	{
  	  if (inFromSpace(page)) // can be moved
  	    *loc = (CmmObject *)((Word)move(p) + (Word)*loc - (Word)p);
***************
*** 1214,1228 ****
  
  #if HEADER_SIZE
  # define CLOSE_CURRENT_PAGE \
! if (freeWords != 0) { \
! 			*firstFreeWord = MAKE_HEADER(freeWords, freeSpaceTag); \
! 			  freeWords = 0; }
  #else
  # define CLOSE_CURRENT_PAGE \
! if (freeWords != 0) { \
! 			*firstFreeWord = *(GCP)aGcFreeObject; \
! 			  SET_OBJECTMAP(firstFreeWord); \
! 			    freeWords = 0; }
  # endif
  
  
--- 1229,1243 ----
  
  #if HEADER_SIZE
  # define CLOSE_CURRENT_PAGE \
!   if (freeWords != 0) { \
!     *firstFreeWord = MAKE_HEADER(freeWords, freeSpaceTag); \
!     freeWords = 0; }
  #else
  # define CLOSE_CURRENT_PAGE \
!   if (freeWords != 0) { \
!     *firstFreeWord = *(GCP)aGcFreeObject; \
!     SET_OBJECTMAP(firstFreeWord); \
!     freeWords = 0; }
  # endif
  
  
***************
*** 1247,1260 ****
  DefaultHeap::collect()
  {
    // firstFreeWord is seen by the collector: it should not consider it a root.
!   
    /* Check for heap not yet allocated */
    if (!Cmm::created)
      {
        CmmHeap::init();
        return;
      }
!   
    /* Log entry to the collector */
    WHEN_VERBOSE (CMM_STATS, {
      scavengeCount = 0;
--- 1262,1275 ----
  DefaultHeap::collect()
  {
    // firstFreeWord is seen by the collector: it should not consider it a root.
! 
    /* Check for heap not yet allocated */
    if (!Cmm::created)
      {
        CmmHeap::init();
        return;
      }
! 
    /* Log entry to the collector */
    WHEN_VERBOSE (CMM_STATS, {
      scavengeCount = 0;
***************
*** 1262,1304 ****
  	    HEAPPERCENT(usedPages));
      newlineIfLogging();
    });
!   
    // CLOSE_CURRENT_PAGE; // not needed: getPages() did it
!   
    /*
     * Pages allocated by move() herein will belong to the StableSpace.
     * At the end of collect() we go back to normal.
     */
    nextSpace = STABLESPACE;
!   usedPages = stablePages; // start counting in StableSpace
!   
  #ifdef CMM_ID
    ncollect++;
  #endif
!   
  # if !HEADER_SIZE || defined(MARKING)
    /* Clear the liveMap bitmap */
    bzero((char*)&liveMap[WORD_INDEX(firstHeapPage * bytesPerPage)],
  	heapSpanPages * (bytesPerPage / bitsPerWord));
  # endif
!   
    bool totalCollection = queueHead == 0;
!   
    // promote pages to StableSpace
    promotionPhase();
!   
    WHEN_VERBOSE (CMM_STATS, {
      fprintf(stderr, "%d%% promoted  ", HEAPPERCENT(usedPages));
      newlineIfLogging();
    });
!   
    // Sweep across stable pages and move their constituent items to StableSpace
    compactionPhase();
!   
    WHEN_VERBOSE (CMM_STATS,
  		fprintf(stderr, "%d%% stable.\n", HEAPPERCENT(stablePages));
  		fprintf(stderr, "Moved objects: %d\n", scavengeCount););
!   
    // Check for total collection and heap expansion
    if (Cmm::generational != 0)
      {
--- 1277,1319 ----
  	    HEAPPERCENT(usedPages));
      newlineIfLogging();
    });
! 
    // CLOSE_CURRENT_PAGE; // not needed: getPages() did it
! 
    /*
     * Pages allocated by move() herein will belong to the StableSpace.
     * At the end of collect() we go back to normal.
     */
    nextSpace = STABLESPACE;
!   usedPages = stablePages;	// start counting in StableSpace
! 
  #ifdef CMM_ID
    ncollect++;
  #endif
! 
  # if !HEADER_SIZE || defined(MARKING)
    /* Clear the liveMap bitmap */
    bzero((char*)&liveMap[WORD_INDEX(firstHeapPage * bytesPerPage)],
  	heapSpanPages * (bytesPerPage / bitsPerWord));
  # endif
! 
    bool totalCollection = queueHead == 0;
! 
    // promote pages to StableSpace
    promotionPhase();
! 
    WHEN_VERBOSE (CMM_STATS, {
      fprintf(stderr, "%d%% promoted  ", HEAPPERCENT(usedPages));
      newlineIfLogging();
    });
! 
    // Sweep across stable pages and move their constituent items to StableSpace
    compactionPhase();
! 
    WHEN_VERBOSE (CMM_STATS,
  		fprintf(stderr, "%d%% stable.\n", HEAPPERCENT(stablePages));
  		fprintf(stderr, "Moved objects: %d\n", scavengeCount););
! 
    // Check for total collection and heap expansion
    if (Cmm::generational != 0)
      {
***************
*** 1319,1325 ****
        emptyStableSpace();
        if (shouldExpandHeap()) expandHeap(Cmm::incHeap);
      }
!   nextSpace = fromSpace; // resume allocating in FromSpace
  }
  
  /*---------------------------------------------------------------------------*
--- 1334,1340 ----
        emptyStableSpace();
        if (shouldExpandHeap()) expandHeap(Cmm::incHeap);
      }
!   nextSpace = fromSpace;	// resume allocating in FromSpace
  }
  
  /*---------------------------------------------------------------------------*
***************
*** 1335,1354 ****
    /* Examine stack, registers, static area and possibly the non-garbage
       collected heap for possible pointers */
    WHEN_VERBOSE (CMM_ROOTLOG, fprintf(stderr, "stack roots:\n"));
!   
    void CmmExamineStaticArea(GCP, GCP);
!   
    /* ensure flushing of register caches	*/
    {
      jmp_buf regs;
      if (_setjmp(regs) == 0) _longjmp(regs, 1);
    }
!   
    /* Examine the stack:		*/
!   GCP fp; /* Pointer for checking the stack.
! 	   * Don't move this earlier or on Solaris it
! 	   * will crash when using -g.
! 	   */
  # ifdef STACK_GROWS_DOWNWARD
    for (fp = (GCP)(&fp+1); fp < (GCP)stackBottom; fp++)
  # else
--- 1350,1369 ----
    /* Examine stack, registers, static area and possibly the non-garbage
       collected heap for possible pointers */
    WHEN_VERBOSE (CMM_ROOTLOG, fprintf(stderr, "stack roots:\n"));
! 
    void CmmExamineStaticArea(GCP, GCP);
! 
    /* ensure flushing of register caches	*/
    {
      jmp_buf regs;
      if (_setjmp(regs) == 0) _longjmp(regs, 1);
    }
! 
    /* Examine the stack:		*/
!   GCP fp;			/* Pointer for checking the stack.
! 				 * Don't move this earlier or on Solaris it
! 				 * will crash when using -g.
! 				 */
  # ifdef STACK_GROWS_DOWNWARD
    for (fp = (GCP)(&fp+1); fp < (GCP)stackBottom; fp++)
  # else
***************
*** 1358,1370 ****
  	WHEN_VERBOSE (CMM_ROOTLOG, logRoot(fp));
  	promotePage((GCP)*fp);
        }
!   
    /* Examine the static areas:		*/
    WHEN_VERBOSE (CMM_ROOTLOG,
  		fprintf(stderr, "Static and registered roots:\n"));
!   
    CmmExamineStaticAreas(CmmExamineStaticArea);
!   
    /* Examine registered roots:		*/
    RootArea* ra;
    for (roots.begin(); ra = roots.get(); )
--- 1373,1385 ----
  	WHEN_VERBOSE (CMM_ROOTLOG, logRoot(fp));
  	promotePage((GCP)*fp);
        }
! 
    /* Examine the static areas:		*/
    WHEN_VERBOSE (CMM_ROOTLOG,
  		fprintf(stderr, "Static and registered roots:\n"));
! 
    CmmExamineStaticAreas(CmmExamineStaticArea);
! 
    /* Examine registered roots:		*/
    RootArea* ra;
    for (roots.begin(); ra = roots.get(); )
***************
*** 1373,1379 ****
        for (int j = ra->bytes; j > 0; j = j - bytesPerWord)
  	promotePage((GCP)*fp++);
      }
!   
    /* Examine the uncollected heap:		*/
    /* Should scan all opaque heaps		*/
    if (Cmm::flags & CMM_HEAPROOTS)
--- 1388,1394 ----
        for (int j = ra->bytes; j > 0; j = j - bytesPerWord)
  	promotePage((GCP)*fp++);
      }
! 
    /* Examine the uncollected heap:		*/
    /* Should scan all opaque heaps		*/
    if (Cmm::flags & CMM_HEAPROOTS)
***************
*** 1418,1432 ****
  void
  DefaultHeap::compactionPhase()
  {
!   GCP  cp, nextcp;	/* Pointers to move constituent objects */
!   
    Page page = queueHead;
    while (page)
      {
  #     ifdef MARKING		// pointers to unmarked objects within
        SET_SCANNED(page);	// this page will have to be traversed
!       // recursively by scavenge()
!       scanPage = page; // scan optimization
  #     endif
        cp = pageToGCP(page);
        WHEN_VERBOSE (CMM_DEBUGLOG, fprintf(stderr, "sweeping 0x%x\n", cp));
--- 1433,1447 ----
  void
  DefaultHeap::compactionPhase()
  {
!   GCP  cp, nextcp;		/* Pointers to move constituent objects */
! 
    Page page = queueHead;
    while (page)
      {
  #     ifdef MARKING		// pointers to unmarked objects within
        SET_SCANNED(page);	// this page will have to be traversed
! 				// recursively by scavenge()
!       scanPage = page;		// scan optimization
  #     endif
        cp = pageToGCP(page);
        WHEN_VERBOSE (CMM_DEBUGLOG, fprintf(stderr, "sweeping 0x%x\n", cp));
***************
*** 1448,1454 ****
  #             endif
  	      )
  	    {
! 	      scanPtr = cp;		// scan optimization
  	      ((CmmObject *)(cp + HEADER_SIZE))->traverse();
  	    }
  	  cp = cp + HEADER_WORDS(*cp);
--- 1463,1469 ----
  #             endif
  	      )
  	    {
! 	      scanPtr = cp;	// scan optimization
  	      ((CmmObject *)(cp + HEADER_SIZE))->traverse();
  	    }
  	  cp = cp + HEADER_WORDS(*cp);
***************
*** 1457,1463 ****
  	  if (MARKED(cp))
  #           endif
  	    {
! 	      scanPtr = cp;		// scan optimization
  	      ((CmmObject *)cp)->traverse();
  	    }
  	  cp = cp + ((CmmObject *)cp)->words();
--- 1472,1478 ----
  	  if (MARKED(cp))
  #           endif
  	    {
! 	      scanPtr = cp;	// scan optimization
  	      ((CmmObject *)cp)->traverse();
  	    }
  	  cp = cp + ((CmmObject *)cp)->words();
***************
*** 1472,1478 ****
  	// whose page gets promoted and added to the queue.
  	CLOSE_CURRENT_PAGE;
      }
!   
  #ifdef MARKING
    {
      /* Restore scanned pages to STABLESPACE */
--- 1487,1493 ----
  	// whose page gets promoted and added to the queue.
  	CLOSE_CURRENT_PAGE;
      }
! 
  #ifdef MARKING
    {
      /* Restore scanned pages to STABLESPACE */
***************
*** 1484,1490 ****
        }
    }
  #endif
!   fromSpace = fromSpace + 1; // Advance space
  }
  
  /*---------------------------------------------------------------------------*
--- 1499,1505 ----
        }
    }
  #endif
!   fromSpace = fromSpace + 1;	// Advance space
  }
  
  /*---------------------------------------------------------------------------*
***************
*** 1514,1528 ****
  GCP
  allocatePages(int pages, CmmHeap *heap)
  {
!   int  	free;		/* # contiguous free pages */
!   Page	firstPage; /* Page # of first free page */
!   int	allPages; /* # of pages in the heap */
!   GCP	firstByte; /* address of first free page */
!   
    allPages = heapSpanPages;
    free = 0;
    firstPage = firstFreePage;
!   
    while (allPages--)
      {
        if (pageHeap[firstFreePage] == NOHEAP)
--- 1529,1543 ----
  GCP
  allocatePages(int pages, CmmHeap *heap)
  {
!   int  	free;			/* # contiguous free pages */
!   Page	firstPage;		/* Page # of first free page */
!   int	allPages;		/* # of pages in the heap */
!   GCP	firstByte;		/* address of first free page */
! 
    allPages = heapSpanPages;
    free = 0;
    firstPage = firstFreePage;
! 
    while (allPages--)
      {
        if (pageHeap[firstFreePage] == NOHEAP)
***************
*** 1583,1602 ****
  GCP
  DefaultHeap::getPages(int pages)
  {
!   Page firstPage;	/* Page # of first free page	*/
!   
    //#define NEW_GETPAGE bad: grows valla to 29063K
  #ifndef NEW_GETPAGE
  #define USED2FREE_RATIO 2
!   if (nextSpace != STABLESPACE /* not within move()  	*/
        && usedPages + pages
        > USED2FREE_RATIO * (freePages + reservedPages - usedPages - pages))
      collect();
  #endif
!   
    /* Discard any remaining portion of current page */
    CLOSE_CURRENT_PAGE;
!   
    if (reservedPages - usedPages > reservedPages / 16)
      // not worth looking for the last few ones dispersed through the heap
      {
--- 1598,1617 ----
  GCP
  DefaultHeap::getPages(int pages)
  {
!   Page firstPage;		/* Page # of first free page	*/
! 
    //#define NEW_GETPAGE bad: grows valla to 29063K
  #ifndef NEW_GETPAGE
  #define USED2FREE_RATIO 2
!   if (nextSpace != STABLESPACE	/* not within move()  	*/
        && usedPages + pages
        > USED2FREE_RATIO * (freePages + reservedPages - usedPages - pages))
      collect();
  #endif
! 
    /* Discard any remaining portion of current page */
    CLOSE_CURRENT_PAGE;
! 
    if (reservedPages - usedPages > reservedPages / 16)
      // not worth looking for the last few ones dispersed through the heap
      {
***************
*** 1687,1700 ****
  #define USED2FREE_RATIO 2
  #define enoughPagesLeft(pages)     (usedPages + pages \
  				    <= USED2FREE_RATIO * (freePages + reservedPages - usedPages - pages))
!      
!      GCP
!      DefaultHeap::alloc(Word size)
! {
!   GCP  object;		/* Pointer to the object */
!   
!   size = bytesToWords(size); // add size of header
!   
    /* Try to allocate from current page */
    if (size <= (Word)freeWords)
      {
--- 1702,1715 ----
  #define USED2FREE_RATIO 2
  #define enoughPagesLeft(pages)     (usedPages + pages \
  				    <= USED2FREE_RATIO * (freePages + reservedPages - usedPages - pages))
! 
! GCP
! DefaultHeap::alloc(Word size)
! {
!   GCP  object;			/* Pointer to the object */
! 
!   size = bytesToWords(size);	// add size of header
! 
    /* Try to allocate from current page */
    if (size <= (Word)freeWords)
      {
***************
*** 1828,1834 ****
  CmmObject::operator new(size_t size, CmmHeap *heap)
  {
    GCP object = heap->alloc(size);
!   
    // To avoid problems in GC after new but during constructor
  #ifdef CMM_ID
    *(object+1) = *((GCP)aCmmObject+1);
--- 1843,1849 ----
  CmmObject::operator new(size_t size, CmmHeap *heap)
  {
    GCP object = heap->alloc(size);
! 
    // To avoid problems in GC after new but during constructor
  #ifdef CMM_ID
    *(object+1) = *((GCP)aCmmObject+1);
***************
*** 1844,1851 ****
   *
   *---------------------------------------------------------------------------*/
  
! void
! CmmObject::operator delete(void *obj)
  {
    (((CmmObject *)obj)->heap())->reclaim((GCP)obj);
  }
--- 1859,1865 ----
   *
   *---------------------------------------------------------------------------*/
  
! void CmmObject::operator delete(void *obj)
  {
    (((CmmObject *)obj)->heap())->reclaim((GCP)obj);
  }
***************
*** 1860,1873 ****
  CmmVarObject::operator new(size_t size, size_t extraSize, CmmHeap *heap)
  {
    GCP object = heap->alloc(size + extraSize);
!   
    // To avoid problems in GC after new() but during constructor
  #ifdef CMM_ID
    *(object+1) = *((GCP)aCmmVarObject+1);
  #else
    *object = *(GCP)aCmmVarObject;
  #endif
!   
    return (void *)object;
  }
  
--- 1874,1887 ----
  CmmVarObject::operator new(size_t size, size_t extraSize, CmmHeap *heap)
  {
    GCP object = heap->alloc(size + extraSize);
! 
    // To avoid problems in GC after new() but during constructor
  #ifdef CMM_ID
    *(object+1) = *((GCP)aCmmVarObject+1);
  #else
    *object = *(GCP)aCmmVarObject;
  #endif
! 
    return (void *)object;
  }
  
***************
*** 1913,1921 ****
  verifyObject(GCP cp, bool old)
  {
    Page  page = GCPtoPage(cp);
!   GCP  xp = pageToGCP(page); /* Ptr to start of page */
    int  error = 0;
!   
    if (page < firstHeapPage) goto fail;
    error = 1;
    if (page > lastHeapPage) goto fail;
--- 1927,1935 ----
  verifyObject(GCP cp, bool old)
  {
    Page  page = GCPtoPage(cp);
!   GCP  xp = pageToGCP(page);	/* Ptr to start of page */
    int  error = 0;
! 
    if (page < firstHeapPage) goto fail;
    error = 1;
    if (page > lastHeapPage) goto fail;
***************
*** 1960,1966 ****
  # endif
    Page pagen = GCPtoPage(cp);
    int error = 0;
!   
    if  FORWARDED(cp[-HEADER_SIZE])  goto fail;
    error = 1;
  # if HEADER_SIZE
--- 1974,1980 ----
  # endif
    Page pagen = GCPtoPage(cp);
    int error = 0;
! 
    if  FORWARDED(cp[-HEADER_SIZE])  goto fail;
    error = 1;
  # if HEADER_SIZE
***************
*** 2011,2028 ****
  logRoot(GCP fp)
  {
    Page  page = GCPtoPage(fp);
!   
    if (page < firstHeapPage
        || page > lastHeapPage
        || inFreeSpace(page))
      return;
!   
    int pages = pageGroup[page];
!   
    if (pages < 0) page += pages;
!   
    GCP  p1, p2 = pageToGCP(page);
!   
    while (p2 < (GCP)fp)
      {
        p1 = p2;
--- 2025,2042 ----
  logRoot(GCP fp)
  {
    Page  page = GCPtoPage(fp);
! 
    if (page < firstHeapPage
        || page > lastHeapPage
        || inFreeSpace(page))
      return;
! 
    int pages = pageGroup[page];
! 
    if (pages < 0) page += pages;
! 
    GCP  p1, p2 = pageToGCP(page);
! 
    while (p2 < (GCP)fp)
      {
        p1 = p2;
***************
*** 2061,2067 ****
    GCP start = pageToGCP(page);
    GCP end = pageToGCP(page + 1);
    GCP ptr;
!   
    for (ptr = start; ptr < end; ptr++)
      promotePage(ptr);
  }
--- 2075,2081 ----
    GCP start = pageToGCP(page);
    GCP end = pageToGCP(page + 1);
    GCP ptr;
! 
    for (ptr = start; ptr < end; ptr++)
      promotePage(ptr);
  }
diff -c /home/omega/attardi/posso/cmm/cmm.h /project/posso/cmm/curr/cmm/cmm.h
*** /home/omega/attardi/posso/cmm/cmm.h	Thu Sep 25 16:07:52 1997
--- /project/posso/cmm/curr/cmm/cmm.h	Wed Sep 17 15:15:05 1997
***************
*** 716,721 ****
--- 716,722 ----
   *
   *---------------------------------------------------------------------------*/
  
+ #define CMM_ID
  class CmmObject
  {
  public:
***************
*** 970,1008 ****
    int  freed;
    int  iter;
  };
- 
- /*---------------------------------------------------------------------------*
-  *
-  * --  Roots
-  *
-  * Roots explicitely registered with the garbage collector are contained in
-  * the following structure, allocated from the non-garbage collected heap.
-  *
-  *---------------------------------------------------------------------------*/
- 
- typedef struct
- {
-   GCP	     addr;		/* Address of the roots */
-   int  	     bytes;		/* Number of bytes in the roots */
- } RootArea;
- 
- class RootAreas
- {
-  public:
-   RootAreas();
-   void insert(void * addr, int bytes);
-   void erase(void* addr);
-   RootArea* get();
-   void begin();
- 
- private:
-   RootArea*	entries;
-   int		last;
-   int		max;
-   int		freed;
-   int		iter;
- };
- 
- extern RootAreas	roots;	/* areas registered as containing roots */
- 
  #endif				// _CMM_H
--- 971,974 ----
diff -c /home/omega/attardi/posso/cmm/cmm.mak /project/posso/cmm/curr/cmm/cmm.mak
*** /home/omega/attardi/posso/cmm/cmm.mak	Thu Sep 25 18:52:10 1997
--- /project/posso/cmm/curr/cmm/cmm.mak	Tue Jul 29 09:44:38 1997
***************
*** 5,12 ****
  # TARGTYPE "Win32 (x86) Static Library" 0x0104
  
  !IF "$(CFG)" == ""
! CFG=test1 - Win32 Debug
! !MESSAGE No configuration specified.  Defaulting to test1 - Win32 Debug.
  !ENDIF 
  
  !IF "$(CFG)" != "cmm - Win32 Release" && "$(CFG)" != "cmm - Win32 Debug" &&\
--- 5,12 ----
  # TARGTYPE "Win32 (x86) Static Library" 0x0104
  
  !IF "$(CFG)" == ""
! CFG=testmsw3 - Win32 Debug
! !MESSAGE No configuration specified.  Defaulting to testmsw3 - Win32 Debug.
  !ENDIF 
  
  !IF "$(CFG)" != "cmm - Win32 Release" && "$(CFG)" != "cmm - Win32 Debug" &&\
***************
*** 14,25 ****
   "$(CFG)" != "test4 - Win32 Debug" && "$(CFG)" != "test5 - Win32 Debug" &&\
   "$(CFG)" != "test6 - Win32 Debug" && "$(CFG)" != "test8 - Win32 Debug" &&\
   "$(CFG)" != "testmsw1 - Win32 Debug" && "$(CFG)" != "testmsw2 - Win32 Debug" &&\
!  "$(CFG)" != "testmsw3 - Win32 Debug" && "$(CFG)" != "test1 - Win32 Debug"
  !MESSAGE Invalid configuration "$(CFG)" specified.
  !MESSAGE You can specify a configuration when running NMAKE on this makefile
  !MESSAGE by defining the macro CFG on the command line.  For example:
  !MESSAGE 
! !MESSAGE NMAKE /f "cmm.mak" CFG="test1 - Win32 Debug"
  !MESSAGE 
  !MESSAGE Possible choices for configuration are:
  !MESSAGE 
--- 14,25 ----
   "$(CFG)" != "test4 - Win32 Debug" && "$(CFG)" != "test5 - Win32 Debug" &&\
   "$(CFG)" != "test6 - Win32 Debug" && "$(CFG)" != "test8 - Win32 Debug" &&\
   "$(CFG)" != "testmsw1 - Win32 Debug" && "$(CFG)" != "testmsw2 - Win32 Debug" &&\
!  "$(CFG)" != "testmsw3 - Win32 Debug"
  !MESSAGE Invalid configuration "$(CFG)" specified.
  !MESSAGE You can specify a configuration when running NMAKE on this makefile
  !MESSAGE by defining the macro CFG on the command line.  For example:
  !MESSAGE 
! !MESSAGE NMAKE /f "cmm.mak" CFG="testmsw3 - Win32 Debug"
  !MESSAGE 
  !MESSAGE Possible choices for configuration are:
  !MESSAGE 
***************
*** 34,40 ****
  !MESSAGE "testmsw1 - Win32 Debug" (based on "Win32 (x86) Console Application")
  !MESSAGE "testmsw2 - Win32 Debug" (based on "Win32 (x86) Console Application")
  !MESSAGE "testmsw3 - Win32 Debug" (based on "Win32 (x86) Console Application")
- !MESSAGE "test1 - Win32 Debug" (based on "Win32 (x86) Console Application")
  !MESSAGE 
  !ERROR An invalid configuration is specified.
  !ENDIF 
--- 34,39 ----
***************
*** 674,684 ****
  ALL : "$(OUTDIR)\testmsw1.exe"
  
  CLEAN : 
- 	-@erase ".\Debug\vc40.pdb"
- 	-@erase ".\Debug\vc40.idb"
  	-@erase ".\Debug\testmsw1.exe"
  	-@erase ".\Debug\testmsw1.obj"
  	-@erase ".\Debug\testmsw1.ilk"
  	-@erase ".\Debug\testmsw1.pdb"
  
  "$(OUTDIR)" :
--- 673,683 ----
  ALL : "$(OUTDIR)\testmsw1.exe"
  
  CLEAN : 
  	-@erase ".\Debug\testmsw1.exe"
  	-@erase ".\Debug\testmsw1.obj"
  	-@erase ".\Debug\testmsw1.ilk"
+ 	-@erase ".\Debug\vc40.pdb"
+ 	-@erase ".\Debug\vc40.idb"
  	-@erase ".\Debug\testmsw1.pdb"
  
  "$(OUTDIR)" :
***************
*** 752,763 ****
  ALL : "$(OUTDIR)\testmsw2.exe"
  
  CLEAN : 
- 	-@erase ".\Debug\vc40.pdb"
- 	-@erase ".\Debug\vc40.idb"
  	-@erase ".\Debug\testmsw2.exe"
  	-@erase ".\Debug\testmsw2.obj"
  	-@erase ".\Debug\testmsw2.ilk"
  	-@erase ".\Debug\testmsw2.pdb"
  
  "$(OUTDIR)" :
      if not exist "$(OUTDIR)/$(NULL)" mkdir "$(OUTDIR)"
--- 751,762 ----
  ALL : "$(OUTDIR)\testmsw2.exe"
  
  CLEAN : 
  	-@erase ".\Debug\testmsw2.exe"
  	-@erase ".\Debug\testmsw2.obj"
  	-@erase ".\Debug\testmsw2.ilk"
  	-@erase ".\Debug\testmsw2.pdb"
+ 	-@erase ".\Debug\vc40.pdb"
+ 	-@erase ".\Debug\vc40.idb"
  
  "$(OUTDIR)" :
      if not exist "$(OUTDIR)/$(NULL)" mkdir "$(OUTDIR)"
***************
*** 830,841 ****
  ALL : "$(OUTDIR)\testmsw3.exe"
  
  CLEAN : 
- 	-@erase ".\Debug\vc40.pdb"
- 	-@erase ".\Debug\vc40.idb"
  	-@erase ".\Debug\testmsw3.exe"
  	-@erase ".\Debug\testmsw3.obj"
  	-@erase ".\Debug\testmsw3.ilk"
  	-@erase ".\Debug\testmsw3.pdb"
  
  "$(OUTDIR)" :
      if not exist "$(OUTDIR)/$(NULL)" mkdir "$(OUTDIR)"
--- 829,840 ----
  ALL : "$(OUTDIR)\testmsw3.exe"
  
  CLEAN : 
  	-@erase ".\Debug\testmsw3.exe"
  	-@erase ".\Debug\testmsw3.obj"
  	-@erase ".\Debug\testmsw3.ilk"
  	-@erase ".\Debug\testmsw3.pdb"
+ 	-@erase ".\Debug\vc40.pdb"
+ 	-@erase ".\Debug\vc40.idb"
  
  "$(OUTDIR)" :
      if not exist "$(OUTDIR)/$(NULL)" mkdir "$(OUTDIR)"
***************
*** 890,972 ****
    $(LINK32_FLAGS) $(LINK32_OBJS)
  <<
  
- !ELSEIF  "$(CFG)" == "test1 - Win32 Debug"
- 
- # PROP BASE Use_MFC 0
- # PROP BASE Use_Debug_Libraries 1
- # PROP BASE Output_Dir "test1\Debug"
- # PROP BASE Intermediate_Dir "test1\Debug"
- # PROP BASE Target_Dir "test1"
- # PROP Use_MFC 0
- # PROP Use_Debug_Libraries 1
- # PROP Output_Dir "Debug"
- # PROP Intermediate_Dir "Debug"
- # PROP Target_Dir "test1"
- OUTDIR=.\Debug
- INTDIR=.\Debug
- 
- ALL : "$(OUTDIR)\test1.exe"
- 
- CLEAN : 
- 	-@erase ".\Debug\vc40.pdb"
- 	-@erase ".\Debug\vc40.idb"
- 	-@erase ".\Debug\test1.exe"
- 	-@erase ".\Debug\test1.obj"
- 	-@erase ".\Debug\test1.ilk"
- 	-@erase ".\Debug\test1.pdb"
- 
- "$(OUTDIR)" :
-     if not exist "$(OUTDIR)/$(NULL)" mkdir "$(OUTDIR)"
- 
- CPP=cl.exe
- # ADD BASE CPP /nologo /W3 /Gm /GX /Zi /Od /D "WIN32" /D "_DEBUG" /D "_CONSOLE" /YX /c
- # ADD CPP /nologo /W3 /Gm /GX /Zi /Od /D "WIN32" /D "_DEBUG" /D "_CONSOLE" /YX /c
- CPP_PROJ=/nologo /MLd /W3 /Gm /GX /Zi /Od /D "WIN32" /D "_DEBUG" /D "_CONSOLE"\
-  /Fp"$(INTDIR)/test1.pch" /YX /Fo"$(INTDIR)/" /Fd"$(INTDIR)/" /c 
- CPP_OBJS=.\Debug/
- CPP_SBRS=
- 
- .c{$(CPP_OBJS)}.obj:
-    $(CPP) $(CPP_PROJ) $<  
- 
- .cpp{$(CPP_OBJS)}.obj:
-    $(CPP) $(CPP_PROJ) $<  
- 
- .cxx{$(CPP_OBJS)}.obj:
-    $(CPP) $(CPP_PROJ) $<  
- 
- .c{$(CPP_SBRS)}.sbr:
-    $(CPP) $(CPP_PROJ) $<  
- 
- .cpp{$(CPP_SBRS)}.sbr:
-    $(CPP) $(CPP_PROJ) $<  
- 
- .cxx{$(CPP_SBRS)}.sbr:
-    $(CPP) $(CPP_PROJ) $<  
- 
- RSC=rc.exe
- # ADD BASE RSC /l 0x809 /d "_DEBUG"
- # ADD RSC /l 0x809 /d "_DEBUG"
- BSC32=bscmake.exe
- # ADD BASE BSC32 /nologo
- # ADD BSC32 /nologo
- BSC32_FLAGS=/nologo /o"$(OUTDIR)/test1.bsc" 
- BSC32_SBRS=
- LINK32=link.exe
- # ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /debug /machine:I386
- # ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /debug /machine:I386
- LINK32_FLAGS=kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib\
-  advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib\
-  odbccp32.lib /nologo /subsystem:console /incremental:yes\
-  /pdb:"$(OUTDIR)/test1.pdb" /debug /machine:I386 /out:"$(OUTDIR)/test1.exe" 
- LINK32_OBJS= \
- 	"$(INTDIR)/test1.obj"
- 
- "$(OUTDIR)\test1.exe" : "$(OUTDIR)" $(DEF_FILE) $(LINK32_OBJS)
-     $(LINK32) @<<
-   $(LINK32_FLAGS) $(LINK32_OBJS)
- <<
- 
  !ENDIF 
  
  ################################################################################
--- 889,894 ----
***************
*** 1325,1333 ****
  # Begin Source File
  
  SOURCE=.\testmsw2.c
- 
- !IF  "$(CFG)" == "testmsw2 - Win32 Debug"
- 
  DEP_CPP_TESTMS=\
  	".\msw.h"\
  	
--- 1247,1252 ----
***************
*** 1335,1342 ****
  "$(INTDIR)\testmsw2.obj" : $(SOURCE) $(DEP_CPP_TESTMS) "$(INTDIR)"
  
  
- !ENDIF 
- 
  # End Source File
  # End Target
  ################################################################################
--- 1254,1259 ----
***************
*** 1347,1355 ****
  # Begin Source File
  
  SOURCE=.\testmsw3.cpp
- 
- !IF  "$(CFG)" == "testmsw3 - Win32 Debug"
- 
  DEP_CPP_TESTMSW=\
  	".\cmm.h"\
  	".\machine.h"\
--- 1264,1269 ----
***************
*** 1357,1383 ****
  	
  
  "$(INTDIR)\testmsw3.obj" : $(SOURCE) $(DEP_CPP_TESTMSW) "$(INTDIR)"
- 
- 
- !ENDIF 
- 
- # End Source File
- # End Target
- ################################################################################
- # Begin Target
- 
- # Name "test1 - Win32 Debug"
- ################################################################################
- # Begin Source File
- 
- SOURCE=.\test1.cpp
- DEP_CPP_TEST1=\
- 	".\cmm.h"\
- 	".\machine.h"\
- 	".\msw.h"\
- 	
- 
- "$(INTDIR)\test1.obj" : $(SOURCE) $(DEP_CPP_TEST1) "$(INTDIR)"
  
  
  # End Source File
--- 1271,1276 ----
Common subdirectories: /home/omega/attardi/posso/cmm/doc and /project/posso/cmm/curr/cmm/doc
diff -c /home/omega/attardi/posso/cmm/msw.cpp /project/posso/cmm/curr/cmm/msw.cpp
*** /home/omega/attardi/posso/cmm/msw.cpp	Thu Sep 25 19:10:58 1997
--- /project/posso/cmm/curr/cmm/msw.cpp	Wed Sep 24 11:22:31 1997
***************
*** 222,229 ****
  #define AllocMask		0x1
  #define MarkMask		0x3
  #define FreeMask		0x0
! #define OpaqueMask		((Byte)0xaa)
! #define TransparentMask		((Byte)0xbb)
  
  /* Page type: values for the page map */
  
--- 222,229 ----
  #define AllocMask		0x1
  #define MarkMask		0x3
  #define FreeMask		0x0
! #define OpaqueMask		0xaa
! #define TransparentMask		0xbb
  
  /* Page type: values for the page map */
  
***************
*** 250,257 ****
   * If there is an attempt of using a free memory object, it should be easy to
   * understand if the mem obj has been released during a collection.
   */
! #define EMPTY_MEM_TAG		((Byte)0xee)
! #define RELEASED_MEM_TAG	((Byte)0xdd)
  
  #define PAGE_START(ptr)		(Ptr)((Word)(ptr) & ~(bytesPerPage - 1))
  
--- 250,257 ----
   * If there is an attempt of using a free memory object, it should be easy to
   * understand if the mem obj has been released during a collection.
   */
! #define EMPTY_MEM_TAG		0xee
! #define RELEASED_MEM_TAG	0xdd
  
  #define PAGE_START(ptr)		(Ptr)((Word)(ptr) & ~(bytesPerPage - 1))
  
***************
*** 538,544 ****
  
  	freePage->allocatedObjs += 1;
  	*freeList = AllocMask;
! 	*(freeList-1) = TransparentMask;
  
  	// Following assignment is needed because subsequent call to
  	// mswAllocFPage might release completely "freePage".
--- 538,544 ----
  
  	freePage->allocatedObjs += 1;
  	*freeList = AllocMask;
! 	*(Byte *)(freeList-1) = TransparentMask;
  
  	// Following assignment is needed because subsequent call to
  	// mswAllocFPage might release completely "freePage".
***************
*** 574,580 ****
  {
  	if (size < MaxFixedSize) {
  	  Ptr ret = (Ptr)mswAlloc(size);
! 	  *(ret-2) = OpaqueMask;
  	  return ret;
  	}
  	else
--- 574,580 ----
  {
  	if (size < MaxFixedSize) {
  	  Ptr ret = (Ptr)mswAlloc(size);
! 	  *(Byte *)(ret-2) = OpaqueMask;
  	  return ret;
  	}
  	else
***************
*** 953,964 ****
  		/* If obj is opaque, then keep it opaque */
  
                  Byte isOpaque;
  
                  if (realSize < MaxFixedSize)
!                   isOpaque = (*((Byte *)p-2) == OpaqueMask);
                  else {
! 		  PageHeader oldHead = (PageHeader)ROUND_DOWN(p, bytesPerPage);
!                   isOpaque = (Byte)oldHead->isOpaque;
                  }
  
  		if (size < MaxFixedSize) {
--- 953,966 ----
  		/* If obj is opaque, then keep it opaque */
  
                  Byte isOpaque;
+                 PageHeader oldHead;
  
                  if (realSize < MaxFixedSize)
!                   isOpaque = (*((Ptr)p-2) == OpaqueMask);
                  else {
! 		  PageHeader oldHead = (PageHeader) ROUND_DOWN(p,
!                                                                bytesPerPage);
!                   isOpaque = (Byte) oldHead->isOpaque;
                  }
  
  		if (size < MaxFixedSize) {
***************
*** 966,973 ****
                            *(newPtr-2) = OpaqueMask;
                  }
  		else {
! 		  PageHeader newHead = (PageHeader)ROUND_DOWN(newPtr,
! 							      bytesPerPage);
  		  newHead->isOpaque = isOpaque;
  		}
  
--- 968,975 ----
                            *(newPtr-2) = OpaqueMask;
                  }
  		else {
! 		  PageHeader newHead = (PageHeader) ROUND_DOWN(newPtr,
! 							       bytesPerPage);
  		  newHead->isOpaque = isOpaque;
  		}
  
***************
*** 1447,1454 ****
  
  static void		mswMarkFromTo(GCP from, GCP to);
  static void		mswExpandMarkStack(void);
- static void		mswMarkRegisteredRoots(void);
- extern RootAreas	roots;	// areas registered as containing roots
  extern char **		environ;
  
  static void
--- 1449,1454 ----
***************
*** 1483,1498 ****
  	mswMarkFromTo((GCP)stackStart, (GCP)stackEnd);
  	mswGcDEBUG(fprintf(gcOut, " (%lu marked from stack)", markedBytes););
  	CmmExamineStaticAreas(mswMarkFromTo);
- 	mswMarkRegisteredRoots();
- }
- 
- static void
- mswMarkRegisteredRoots()
- {
-      roots.begin();
-      RootArea* ra;
-      while (ra = roots.get())
-        mswMarkFromTo((GCP)ra->addr, (GCP)((Ptr)ra->addr) + ra->bytes);
  }
  
  unsigned maxDepth = 0;
--- 1483,1488 ----
***************
*** 1533,1542 ****
  	    header->isMarked = 1;
  
  	    /* If opaque, don't traverse it */
! 	    assert(*((Byte*)bp-1) == OpaqueMask ||
! 		   *((Byte*)bp-1) == TransparentMask);
  
! 	    if (*((Byte*)bp-1) == OpaqueMask)
  	      continue;
  
  	    mswMarkFromTo((GCP)(bp+1),
--- 1523,1532 ----
  	    header->isMarked = 1;
  
  	    /* If opaque, don't traverse it */
! 	    assert(*(bp-1) == OpaqueMask ||
! 		   *(bp-1) == TransparentMask);
  
! 	    if (*(Byte *)(bp-1) == OpaqueMask)
  	      continue;
  
  	    mswMarkFromTo((GCP)(bp+1),
***************
*** 1610,1619 ****
        header->isMarked = 1;
  		
        /* If opaque, don't traverse it */
!       assert(*((Byte*)bp-1) == OpaqueMask ||
! 	     *((Byte*)bp-1) == TransparentMask);
  		
!       if (*((Byte*)bp-1) == OpaqueMask)
  	continue;
  		
        MarkStackPush((GCP)(bp+1));
--- 1600,1609 ----
        header->isMarked = 1;
  		
        /* If opaque, don't traverse it */
!       assert(*(bp-1) == OpaqueMask ||
! 	     *(bp-1) == TransparentMask);
  		
!       if (*(Byte *)(bp-1) == OpaqueMask)
  	continue;
  		
        MarkStackPush((GCP)(bp+1));
***************
*** 1694,1703 ****
        header->isMarked = 1;
  
        /* If opaque, don't traverse it */
!       assert(*((Byte*)bp-1) == OpaqueMask ||
! 	     *((Byte*)bp-1) == TransparentMask);
  
!       if (*((Byte*)bp-1) == OpaqueMask)
  	continue;
  
        MarkStackPush(pt+1);
--- 1684,1693 ----
        header->isMarked = 1;
  
        /* If opaque, don't traverse it */
!       assert(*(bp-1) == OpaqueMask ||
! 	     *(bp-1) == TransparentMask);
  
!       if (*(Byte *)(bp-1) == OpaqueMask)
  	continue;
  
        MarkStackPush(pt+1);
***************
*** 2653,2660 ****
  	firstObjOff = FPagesInfo[size].firstObjOffset;
  
  	for (p = page + firstObjOff; p <= hi; p += size1) {
! 	  assert(*(p-1) == TransparentMask
! 		 || *(p-1) == OpaqueMask);
  	  assert(*p == AllocMask || *p == FreeMask);
  	  if (*p == AllocMask)
  	    allocatedObjs += 1;
--- 2643,2650 ----
  	firstObjOff = FPagesInfo[size].firstObjOffset;
  
  	for (p = page + firstObjOff; p <= hi; p += size1) {
! 	  assert(*(Byte *)(p-1) == TransparentMask
! 		 || *(Byte *)(p-1) == OpaqueMask);
  	  assert(*p == AllocMask || *p == FreeMask);
  	  if (*p == AllocMask)
  	    allocatedObjs += 1;
diff -c /home/omega/attardi/posso/cmm/test1.cpp /project/posso/cmm/curr/cmm/test1.cpp
*** /home/omega/attardi/posso/cmm/test1.cpp	Thu Sep 25 16:27:07 1997
--- /project/posso/cmm/curr/cmm/test1.cpp	Mon Sep  8 12:10:27 1997
***************
*** 163,169 ****
  void
  listtest2()
  {
!   int  i, j, length = 10000, repeat = 100;
    CP  lp, zp;
  
    printf("List Test 2\n");
--- 163,169 ----
  void
  listtest2()
  {
!   int  i, j, length = 10000, repeat = 1000;
    CP  lp, zp;
  
    printf("List Test 2\n");
diff -c /home/omega/attardi/posso/cmm/test9.cpp /project/posso/cmm/curr/cmm/test9.cpp
*** /home/omega/attardi/posso/cmm/test9.cpp	Thu Sep 25 16:24:34 1997
--- /project/posso/cmm/curr/cmm/test9.cpp	Mon Sep  8 12:12:25 1997
***************
*** 13,18 ****
--- 13,20 ----
   *
   */
  
+ extern "C" long random();
+ 
  // For this values it works
  //const int length1=10;
  //const int length2=15;
***************
*** 117,123 ****
    localpointer=p;
    localpointer->set(0);
  
!   counter= rand() & 700;
    newpointer = new(counter*sizeof(long)+2*sizeof(TestClass*)) TestClass;
    newpointer->counter=counter;
  
--- 119,125 ----
    localpointer=p;
    localpointer->set(0);
  
!   counter=(random()&700);
    newpointer = new(counter*sizeof(long)+2*sizeof(TestClass*)) TestClass;
    newpointer->counter=counter;
  
***************
*** 131,137 ****
      localpointer->setp2(NULL);
      localpointer->setp1(NULL);
  
!     counter=(rand()&700);
      newpointer = new(counter*sizeof(long)+2*sizeof(TestClass*)) TestClass;
      newpointer->counter=counter;
  
--- 133,139 ----
      localpointer->setp2(NULL);
      localpointer->setp1(NULL);
  
!     counter=(random()&700);
      newpointer = new(counter*sizeof(long)+2*sizeof(TestClass*)) TestClass;
      newpointer->counter=counter;
  
***************
*** 156,162 ****
  
    localpointer->set(0);
  
!   counter=(rand()&700);
    //cout << counter << " ";
    newpointer = new(counter*sizeof(long)+2*sizeof(TestClass*)) TestClass;
    newpointer->counter=counter;
--- 158,164 ----
  
    localpointer->set(0);
  
!   counter=(random()&700);
    //cout << counter << " ";
    newpointer = new(counter*sizeof(long)+2*sizeof(TestClass*)) TestClass;
    newpointer->counter=counter;
***************
*** 171,177 ****
      localpointer->setp1(NULL);
      localpointer->setp2(NULL);
  
!     counter=(rand()&700);
      newpointer = new(counter*sizeof(long)+2*sizeof(TestClass*)) TestClass;
      newpointer->counter=counter;
  
--- 173,179 ----
      localpointer->setp1(NULL);
      localpointer->setp2(NULL);
  
!     counter=(random()&700);
      newpointer = new(counter*sizeof(long)+2*sizeof(TestClass*)) TestClass;
      newpointer->counter=counter;
  
***************
*** 222,228 ****
  
    cout << "Process 0 is initializing the base pointer of the two lists!\n";
  
!   count=(rand()&700);
    p0 = new(count*sizeof(long)+2*sizeof(TestClass*)) TestClass;
    p0->setp1(NULL);
    p0->setp2(NULL);
--- 224,230 ----
  
    cout << "Process 0 is initializing the base pointer of the two lists!\n";
  
!   count=(random()&700);
    p0 = new(count*sizeof(long)+2*sizeof(TestClass*)) TestClass;
    p0->setp1(NULL);
    p0->setp2(NULL);
