diff -c /home/omega/attardi/posso/cmm/ChangeLog /project/posso/cmm/curr/cmm/ChangeLog
*** /home/omega/attardi/posso/cmm/ChangeLog	Thu Mar  6 20:30:31 1997
--- /project/posso/cmm/curr/cmm/ChangeLog	Tue Feb 25 23:00:45 1997
***************
*** 1,53 ****
- Thu Mar  6 20:28:35 1997  Giuseppe Attardi  <attardi@omega>
- 
- 	* cmm.cpp (expandHeap): fixed for Linux ELF
- 	 Sometimes malloc() allocates small blocks at quite distant addresses
- 	 from large blocks. In this case tablePages would be huge,
- 	 to encompass the gap between the blocks.
- 	 Therefore we don't recycle them.
- 
- Wed Feb 26 11:35:32 1997  Giuseppe Attardi  <attardi@omega>
- 
- 	* cmm.cpp (scavenge): optimization to avoid traversal of object
- 	in page being scanned must compare with scanPtr, rather then loc,
- 	since traverse may be called recursively from another page.
- 
- 	* cmm.h (DefaultHeap): added scanPtr
- 	scanning -> scanPage
- 
- Tue Feb 25 16:10:12 1997  Giuseppe Attardi  <attardi@omega>
- 
- 	* cmm.cpp (collect): loop which restores scanned pages to STABLESPACE
- 	should not stop at lastStable.
- 	Suggestion by Christian Heckler <chh@plato.uni-paderborn.de>
- 
- Thu Feb 20 12:49:20 1997  Giuseppe Attardi  <attardi@omega>
- 
- 	* cmm.cpp (scavenge): avoid recursive traversal for objects which
- 	are later in the page being scanned.
- 
- 	* cmm.h (DefaultHeap): added member scanning.
- 
- Wed Feb 19 20:30:42 1997  Giuseppe Attardi  <attardi@omega>
- 
- 	* cmm.h (CmmHeap): opaque turned into protected
- 
- Mon Jan 20 16:44:58 1997  Giuseppe Attardi  <attardi@omega>
- 
- 	* cmm.h (UncollectedHeap): added constructor to make heap opaque
- 
- Mon Jan 13 12:32:57 1997  Giuseppe Attardi  <attardi@omega>
- 
- 	* cmm.h (visit): isMarked -> marked
- 
- Thu Jan  9 09:04:37 1997  Giuseppe Attardi  <attardi@omega>
- 
- 	* cmm.cpp: eliminated useless CmmObject::new[] and CmmObject::delete[]
- 
- 	* test5.cpp: eliminated unused references to tempheap
- 
- 	* cmm.cpp (CmmObject::new[]): revised to use CmmArray
- 
  Tue Jan  7 10:43:54 1997  Giuseppe Attardi  <attardi@omega>
  
  	* msw.cpp (mswSelect): added to select M&S heap from C
--- 1,3 ----
***************
*** 64,105 ****
  
  	* cmm.cpp (RootArea): fixed typedef syntax
  
- Sun Dec 22 10:05:24 1996  Giuseppe Attardi  <attardi@omega>
- 
- 	* cmm.h (Set): added template class Set.
- 
- 	* doc/CMMguide.tex (subsection{Array of CmmObject's}):
- 	revised to describe new implementation
- 
- 	* tempheap.h (RootSet): used template class Set for dealing with
- 	sets of roots.
- 	Class RootSet now contains two members:
- 	  Set<CmmObject>  roots;
- 	  Set<CmmObject*> rootsLoc;
- 
- 	* cmm.cpp: changed gcRoots() and gcUnroots() to
- 	registerRootArea() and unregisterRootArea(), which use the classes
- 	RootArea and RootAreas
- 
- 	* tempheap.cpp (RootSet): renamed
- 	set -> insert
- 	setp -> insert
- 	unset -> erase
- 	unsetp -> erase
- 
- 	* cmm.h (CmmHeap): added reservedPages. Requires recompiling
- 	all applications
- 
- 	* msw.cpp (MarkAndSweep): constructor replaces mswInit()
- 
- 	* cmm.cpp (allocatePages): updates reservedPages
- 
- 	* cmm.h (_CmmInit): eliminated  ~_CmmInit()
- 
- 	* cmm.cpp (collect): restore scanned pages up to scan != lastStable
- 
- 	* machine.h: renamed type page -> Page
- 
  Wed Dec 18 17:07:57 1996  Giuseppe Attardi  <attardi@omega>
  
  	* cmm.cpp (CmmInit): heap rounding requires cast to (Word) for
--- 14,19 ----
***************
*** 109,143 ****
  
  	* cmm.cpp (emptyStableSpace): check for empty queue
  	* test7.cpp (class Item): added public to CmmObject
- 
- Sun Dec 15 20:04:45 1996  Giuseppe Attardi  <attardi@omega>
- 
- 	* msw.cpp (mswAlloc, mswAllocOpaque): added casts:
- 	*(Byte *)(freeList-1) = TransparentMask;
- 	*(Byte *)(ret-2) = OpaqueMask
- 
- 	* machine.h: changed basic types:
- 	typedef char *		Ptr;
- 	typedef Ptr *		GCP;
- 
- 	* msw.cpp: added various fixes by Iglio
- 
- Sun Dec  8 13:57:08 1996  Giuseppe Attardi  <attardi@omega>
- 
- 	* cmm.cpp (promotePage): added test OUTSIDE_HEAPS before MARK.
- 	Was causing failure in test4 with new MSW initialization.
- 
- 	* cmm.h: revised mechanism for CmmArray.
- 	Arrays of CmmObject's can be created and used with the standard
- 	syntax provided	one overloads new[] for the class used for elements.
- 	Solution is dependent on GCC.
- 	test7 now works
- 
- 	* test7.cpp (test): revised to use new mechanism.
- 
- Tue Dec  3 19:31:53 1996  Giuseppe Attardi  <attardi@omega>
- 
- 	* README: added Win32 port
  
  Mon Dec  2 09:20:32 1996  Giuseppe Attardi  <attardi@omega>
  
--- 23,28 ----
Only in /project/posso/cmm/curr/cmm: ChangeLog.orig
Only in /project/posso/cmm/curr/cmm: ChangeLog.rej
Only in /home/omega/attardi/posso/cmm: CmmUpgrade
diff -c /home/omega/attardi/posso/cmm/Makefile /project/posso/cmm/curr/cmm/Makefile
*** /home/omega/attardi/posso/cmm/Makefile	Thu Feb 20 12:46:24 1997
--- /project/posso/cmm/curr/cmm/Makefile	Tue Feb 25 23:00:45 1997
***************
*** 31,36 ****
--- 31,37 ----
  #  "test"  compiles and runs all tests (listed in TESTS) reporting which
  #        ones succeeded and which failed.
  #  "clean"  removes all object code from this directory.
+ #  "demo1", "demo2" etc. run various demonstration programs.
  
  CFLAGS	= -O2
  CC	= g++
***************
*** 39,45 ****
  
  OBJS = 	cmm.o tempheap.o msw.o memory.o
  
! TESTS = test2 test3 test4 test5 test6 test7 test8 testmsw1 testmsw2 testmsw3
  
  all: libCmm.a
  
--- 40,46 ----
  
  OBJS = 	cmm.o tempheap.o msw.o memory.o
  
! TESTS = test2 test3 test4 test5 test6 test7 testmsw1 testmsw2 testmsw3
  
  all: libCmm.a
  
***************
*** 81,88 ****
  	$(CC) $(CFLAGS) -o test6 test6.cpp libCmm.a 
  test7:	test7.cpp libCmm.a
  	$(CC) $(CFLAGS) -o test7 test7.cpp libCmm.a 
- test8:	test8.cpp libCmm.a
- 	$(CC) $(CFLAGS) -o test8 test8.cpp libCmm.a 
  testmsw1: testmsw1.c libCmm.a
  	$(CC) $(CFLAGS) -g -o testmsw1 testmsw1.c libCmm.a
  testmsw2: testmsw2.c libCmm.a
--- 82,87 ----
Only in /project/posso/cmm/curr/cmm: Makefile.orig
diff -c /home/omega/attardi/posso/cmm/Makefile.schema /project/posso/cmm/curr/cmm/Makefile.schema
*** /home/omega/attardi/posso/cmm/Makefile.schema	Tue Feb 25 18:30:50 1997
--- /project/posso/cmm/curr/cmm/Makefile.schema	Thu Nov 28 10:27:22 1996
***************
*** 14,20 ****
  
  OBJS = 	cmm.o tempheap.o msw.o memory.o
  
! TESTS = test2 test3 test4 test5 test6 test7 test8 testmsw1 testmsw2 testmsw3
  
  all: libCmm.a
  
--- 14,20 ----
  
  OBJS = 	cmm.o tempheap.o msw.o memory.o
  
! TESTS = test2 test3 test4 test5 test6 test7 testmsw1 testmsw2 testmsw3
  
  all: libCmm.a
  
***************
*** 62,70 ****
  
  test7:	test7.cpp libCmm.a
  	${CPP} -o test7 ${CFLAGS} test7.cpp libCmm.a 
- 
- test8:	test8.cpp libCmm.a
- 	${CPP} -o test8 ${CFLAGS} test8.cpp libCmm.a 
  
  testmsw1: testmsw1.c libCmm.a
  	${CPP} -g -o testmsw1 ${CFLAGS} testmsw1.c libCmm.a
--- 62,67 ----
diff -c /home/omega/attardi/posso/cmm/README /project/posso/cmm/curr/cmm/README
*** /home/omega/attardi/posso/cmm/README	Tue Dec  3 19:32:22 1996
--- /project/posso/cmm/curr/cmm/README	Tue Feb 25 22:46:56 1997
***************
*** 49,58 ****
  
   - SunOS 4.x
   - Solaris 2.x
!  - Linux 1.x, 2.x
   - AIX (RS6000)
   - SGI
-  - Win32 (Windows 95, Windows NT)
  
  but it should run without changes also on HPUX, NeXTOS and DOS (djgpp).
  If you are interest in some other platforms you can send mail to
--- 49,57 ----
  
   - SunOS 4.x
   - Solaris 2.x
!  - Linux 1.x
   - AIX (RS6000)
   - SGI
  
  but it should run without changes also on HPUX, NeXTOS and DOS (djgpp).
  If you are interest in some other platforms you can send mail to
Only in /project/posso/cmm/curr/cmm: README.orig
diff -c /home/omega/attardi/posso/cmm/cmm.cpp /project/posso/cmm/curr/cmm/cmm.cpp
*** /home/omega/attardi/posso/cmm/cmm.cpp	Thu Mar  6 20:32:10 1997
--- /project/posso/cmm/curr/cmm/cmm.cpp	Tue Feb 25 23:00:46 1997
***************
*** 1,6 ****
  /*---------------------------------------------------------------------------*
   *
!  *  cmm.cpp:	This module implements the PoSSo Customisable Memory Manager
   *		(CMM). CMM provides garbage collected storage for C++ programs.
   *  date:	3 January 1995
   *  authors:	Giuseppe Attardi and Tito Flagella
--- 1,6 ----
  /*---------------------------------------------------------------------------*
   *
!  *  cmm.cpp:	This module implements the POSSO Customisable Memory Management
   *		(CMM). CMM provides garbage collected storage for C++ programs.
   *  date:	3 January 1995
   *  authors:	Giuseppe Attardi and Tito Flagella
***************
*** 12,17 ****
--- 12,19 ----
   *  Copyright (C) 1990 Digital Equipment Corporation.
   *  Copyright (C) 1993, 1994, 1995, 1996 Giuseppe Attardi and Tito Flagella.
   *
+  *  This file is part of the PoSSo Customizable Memory Manager (CMM).
+  *
   * Permission to use, copy, and modify this software and its documentation is
   * hereby granted only under the following terms and conditions.  Both the
   * above copyright notice and this permission notice must appear in all copies
***************
*** 54,60 ****
  
  /* Version tag */
  
! char*  Cmm::version = "CMM 1.8.4";
  
  /*---------------------------------------------------------------------------*
   *
--- 56,62 ----
  
  /* Version tag */
  
! char*  Cmm::version = "CMM 1.8.1";
  
  /*---------------------------------------------------------------------------*
   *
***************
*** 73,79 ****
  static int   heapSpanPages;	/* # of pages that span the heap	*/
  int          freePages;	        /* # of pages not yet allocated		*/
  static int   freeWords = 0;	/* # words left on the current page	*/
! static Ptr   *firstFreeWord;	/* Ptr to the first free word on the current
  				   page */
  Page	     firstFreePage;	/* First possible free page		*/
  static Page  queueHead;		/* Head of list of stable set of pages	*/
--- 75,81 ----
  static int   heapSpanPages;	/* # of pages that span the heap	*/
  int          freePages;	        /* # of pages not yet allocated		*/
  static int   freeWords = 0;	/* # words left on the current page	*/
! static long  *firstFreeWord;	/* Ptr to the first free word on the current
  				   page */
  Page	     firstFreePage;	/* First possible free page		*/
  static Page  queueHead;		/* Head of list of stable set of pages	*/
***************
*** 96,102 ****
  				   StableSpace within collect().	*/
  
  int          tablePages;	/* # of pages used by tables		*/
! static Page  firstTablePage;	/* index of first page used by table	*/
  
  /*----------------------------------------------------------------------*
   * -- Page spaces
--- 98,104 ----
  				   StableSpace within collect().	*/
  
  int          tablePages;	/* # of pages used by tables		*/
! page         firstTablePage;	/* index of first page used by table	*/
  
  /*----------------------------------------------------------------------*
   * -- Page spaces
***************
*** 240,250 ****
  #if HEADER_SIZE
  static int  freeSpaceTag = MAKE_TAG(0);
  # ifdef DOUBLE_ALIGN
! static Ptr  doublepad = MAKE_HEADER(1, MAKE_TAG(1));
  #define HEADER_ALIGN(firstFreeWord, freeWords) \
        if  ((freeWords & 1) == 0  &&  freeWords)  { \
  	  *firstFreeWord++ = doublepad; \
! 	  freeWords--; \
  	}
  # endif  // DOUBLE_ALIGN
  #endif // HEADER_SIZE
--- 242,252 ----
  #if HEADER_SIZE
  static int  freeSpaceTag = MAKE_TAG(0);
  # ifdef DOUBLE_ALIGN
! static int  doublepad = MAKE_HEADER(1, MAKE_TAG(1));
  #define HEADER_ALIGN(firstFreeWord, freeWords) \
        if  ((freeWords & 1) == 0  &&  freeWords)  { \
  	  *firstFreeWord++ = doublepad; \
! 	  freeWords = freeWords - 1; \
  	}
  # endif  // DOUBLE_ALIGN
  #endif // HEADER_SIZE
***************
*** 265,271 ****
  // constructor is called before main().
  static _CmmInit _DummyCmmInit;
  
- 
  /*---------------------------------------------------------------------------*
   *
   * --  Roots
--- 267,272 ----
***************
*** 310,319 ****
  	{
  	  RootArea  *np;
  	  max += setIncrement;
! 	  np = ::new RootArea[max];
  	  for (int i = 0; i < count; i++)
  	    np[i] = entries[i];
! 	  ::delete  entries;
  	  entries = np;
  	}
        entries[count].addr = (GCP)addr;
--- 311,320 ----
  	{
  	  RootArea  *np;
  	  max += setIncrement;
! 	  np = new RootArea[max];
  	  for (int i = 0; i < count; i++)
  	    np[i] = entries[i];
! 	  delete  entries;
  	  entries = np;
  	}
        entries[count].addr = (GCP)addr;
***************
*** 401,407 ****
    int shift = BIT_INDEX(this+1);
    register unsigned long bits = objectMap[index] >> shift;
    register int inner = bitsPerWord - shift;
!   Page nextPage = GCPtoPage(this);
    nextPage += pageGroup[nextPage];
    int max = ((int)pageToGCP(nextPage) - (int)this)
      / (bitsPerWord * bytesPerWord);
--- 402,408 ----
    int shift = BIT_INDEX(this+1);
    register unsigned long bits = objectMap[index] >> shift;
    register int inner = bitsPerWord - shift;
!   page nextPage = GCPtoPage(this);
    nextPage += pageGroup[nextPage];
    int max = ((int)pageToGCP(nextPage) - (int)this)
      / (bitsPerWord * bytesPerWord);
***************
*** 496,505 ****
  # endif
  #endif				// HEADER_SIZE
  
! DefaultHeap	*Cmm::theDefaultHeap;
  UncollectedHeap *Cmm::theUncollectedHeap;
- CmmHeap		*Cmm::theMSHeap;
  CmmHeap		*Cmm::heap;
  
  // used during initialization of objects:
  static CmmObject	*aCmmObject;
--- 497,506 ----
  # endif
  #endif				// HEADER_SIZE
  
! DefaultHeap *Cmm::theDefaultHeap;
  UncollectedHeap *Cmm::theUncollectedHeap;
  CmmHeap		*Cmm::heap;
+ CmmHeap		*Cmm::theMSHeap = (CmmHeap*) 100; // 100 to get it working with C
  
  // used during initialization of objects:
  static CmmObject	*aCmmObject;
***************
*** 522,527 ****
--- 523,529 ----
  DefaultHeap::DefaultHeap()
  {
    usedPages 	= 0;
+   reservedPages	= 0;
    stablePages 	= 0;
  }
  
***************
*** 534,555 ****
   *
   *---------------------------------------------------------------------------*/
  
- #if !HEADER_SIZE || defined(MARKING)
- # define tableFraction (sizeof(int)*2 /* pageLink, pageHeap */\
- 		+ sizeof(short)*2     /* pageSpace, pageGroup */\
- 		+ wordsPerPage/bitsPerWord*bytesPerWord /* objectMap */\
- 		+ wordsPerPage/bitsPerWord*bytesPerWord) /* liveMap */
- #else
- # define tableFraction (sizeof(int)*2 /* pageLink, pageHeap */\
- 		+ sizeof(short)*2     /* pageSpace, pageGroup */\
- 		+ wordsPerPage/bitsPerWord*bytesPerWord) /* objectMap */
- #endif
- 
  void
  CmmInit()
  {
    char  *heap;
!   Page  i;
  
    /* Log actual heap parameters if from environment or logging */
    if ((environmentValue("CMM_MINHEAP", Cmm::minHeap)
--- 536,546 ----
   *
   *---------------------------------------------------------------------------*/
  
  void
  CmmInit()
  {
    char  *heap;
!   page  i;
  
    /* Log actual heap parameters if from environment or logging */
    if ((environmentValue("CMM_MINHEAP", Cmm::minHeap)
***************
*** 567,574 ****
  
    /* Allocate heap and side tables.  Exit on allocation failure. */
    heapSpanPages = totalPages = (Cmm::minHeap + bytesPerPage - 1)/bytesPerPage;
!   tablePages = (totalPages*tableFraction + bytesPerPage - 1) / bytesPerPage;
! 
    /* Allocate one block for both the heap and the tables.
     * The tables will be recycled into pages at the next collection.
     */
--- 558,570 ----
  
    /* Allocate heap and side tables.  Exit on allocation failure. */
    heapSpanPages = totalPages = (Cmm::minHeap + bytesPerPage - 1)/bytesPerPage;
!   tablePages = (totalPages*sizeof(int)*2 /* pageLink, pageHeap */
! 		+ totalPages*sizeof(short)*2 /* pageSpace, pageGroup */
! 		+ totalPages*wordsPerPage/bitsPerWord*bytesPerWord /* objectMap */
! #               if !HEADER_SIZE || defined(MARKING)
! 		+ totalPages*wordsPerPage/bitsPerWord*bytesPerWord /* liveMap */
! #               endif
! 		+ bytesPerPage - 1) / bytesPerPage;
    /* Allocate one block for both the heap and the tables.
     * The tables will be recycled into pages at the next collection.
     */
***************
*** 580,590 ****
  	      "\n****** CMM  Unable to allocate %d byte heap\n", Cmm::minHeap);
        abort();
      }
- #ifdef _WIN32
    globalHeapStart = heap;
- #endif
    heap = heap + bytesPerPage - 1;
!   heap -= (Word)heap % bytesPerPage;
    firstHeapPage = GCPtoPage(heap);
    lastHeapPage = firstHeapPage + heapSpanPages - 1;
    firstTablePage = lastHeapPage + 1;
--- 576,584 ----
  	      "\n****** CMM  Unable to allocate %d byte heap\n", Cmm::minHeap);
        abort();
      }
    globalHeapStart = heap;
    heap = heap + bytesPerPage - 1;
!   heap -= (long)heap % bytesPerPage;
    firstHeapPage = GCPtoPage(heap);
    lastHeapPage = firstHeapPage + heapSpanPages - 1;
    firstTablePage = lastHeapPage + 1;
***************
*** 592,598 ****
  
    pageSpace = (short *)pageToGCP(firstTablePage);
    pageGroup = &pageSpace[totalPages];
!   pageLink = (Page *)&pageGroup[totalPages];
    pageHeap = (CmmHeap **)&pageLink[totalPages];
    objectMap = (unsigned long *)&pageHeap[totalPages];
  # if !HEADER_SIZE || defined(MARKING)
--- 586,592 ----
  
    pageSpace = (short *)pageToGCP(firstTablePage);
    pageGroup = &pageSpace[totalPages];
!   pageLink = (page *)&pageGroup[totalPages];
    pageHeap = (CmmHeap **)&pageLink[totalPages];
    objectMap = (unsigned long *)&pageHeap[totalPages];
  # if !HEADER_SIZE || defined(MARKING)
***************
*** 618,623 ****
--- 612,622 ----
    /* Initialize tables */
    for (i = firstHeapPage ; i <= lastHeapPage ; i++)
      pageHeap[i] = NOHEAP;
+ 
+ # ifdef _WIN32
+   pageLink[0] = 0;	// _WIN32 malloc does not clear. Needed for expandHeap
+ # endif
+ 
    fromSpace = UNALLOCATEDSPACE + 1;
    nextSpace = fromSpace;
    firstFreePage = firstHeapPage;
***************
*** 625,630 ****
--- 624,630 ----
    Cmm::created = true;
  
    Cmm::theDefaultHeap->usedPages 	= 0;
+   Cmm::theDefaultHeap->reservedPages 	= 0;
    Cmm::theDefaultHeap->stablePages 	= 0;
    Cmm::theDefaultHeap->firstUnusedPage	= firstHeapPage;
    Cmm::theDefaultHeap->firstReservedPage= firstHeapPage;
***************
*** 681,703 ****
   *
   *---------------------------------------------------------------------------*/
  
- #define distant(x, y) (abs(x - y) > 1000)
- 
  static int
  expandHeap(int increment)
  {
    int  inc_totalPages = increment/bytesPerPage;
!   Page  new_firstHeapPage;
!   Page  inc_firstHeapPage;
!   Page  new_lastHeapPage;
!   Page  inc_lastHeapPage;
    int  new_totalPages;
!   Page  *new_pageLink;
    unsigned long  *new_objectMap;
  # if !HEADER_SIZE || defined(MARKING)
    unsigned long  *new_liveMap;
  # endif
!   Page  i;
  
    short *new_pageSpace;
    short *new_pageGroup;
--- 681,701 ----
   *
   *---------------------------------------------------------------------------*/
  
  static int
  expandHeap(int increment)
  {
    int  inc_totalPages = increment/bytesPerPage;
!   page  new_firstHeapPage;
!   page  inc_firstHeapPage;
!   page  new_lastHeapPage;
!   page  inc_lastHeapPage;
    int  new_totalPages;
!   page  *new_pageLink;
    unsigned long  *new_objectMap;
  # if !HEADER_SIZE || defined(MARKING)
    unsigned long  *new_liveMap;
  # endif
!   page  i;
  
    short *new_pageSpace;
    short *new_pageGroup;
***************
*** 706,718 ****
    char  *new_tables;
    int   new_tablePages;
    char  *inc_heap;
-   bool recycleOldTables = true;
  
    /* Check for previous expansion failure */
    if (expandFailed) return  0;
  
-   Page lastTablePage = firstTablePage + tablePages - 1;
- 
    /* Allocate additional heap and determine page span */
  
  #ifndef _WIN32
--- 704,713 ----
***************
*** 724,754 ****
    inc_heap = ::new char[inc_totalPages*bytesPerPage + bytesPerPage - 1];
    if (inc_heap == NULL) goto fail;
    inc_heap = inc_heap + bytesPerPage - 1;
!   inc_heap -= (Word)inc_heap % bytesPerPage;
    inc_firstHeapPage = GCPtoPage(inc_heap);
    inc_lastHeapPage = inc_firstHeapPage + inc_totalPages - 1;
! 
!   new_firstHeapPage = MIN(firstHeapPage, inc_firstHeapPage);
!   new_lastHeapPage = MAX(lastHeapPage, inc_lastHeapPage);
!   /* Sometimes malloc() (e.g. on Linux ELF) allocates small blocks at
!    * quite distant addresses from large blocks. In this case tablePages
!    * would be huge, to encompass the gap between the blocks.
!    * Therefore we don't recycle them.
!    */
!   if (distant(lastHeapPage, firstTablePage)
!       && distant(lastTablePage, firstHeapPage))
!     recycleOldTables = false;
! 
!   if (recycleOldTables)
!     {
!       new_firstHeapPage = MIN(new_firstHeapPage, firstTablePage);
!       new_lastHeapPage = MAX(new_lastHeapPage,
! 			     firstTablePage + tablePages - 1);
!     }
    new_totalPages = totalPages + tablePages + inc_totalPages;
    heapSpanPages = new_lastHeapPage - new_firstHeapPage + 1;
  
!   new_tablePages = (heapSpanPages*tableFraction
  		    + bytesPerPage - 1) / bytesPerPage;
    new_tables = ::new char[new_tablePages*bytesPerPage + bytesPerPage - 1];
    if (new_tables == NULL)
--- 719,741 ----
    inc_heap = ::new char[inc_totalPages*bytesPerPage + bytesPerPage - 1];
    if (inc_heap == NULL) goto fail;
    inc_heap = inc_heap + bytesPerPage - 1;
!   inc_heap -= (int)inc_heap % bytesPerPage;
    inc_firstHeapPage = GCPtoPage(inc_heap);
    inc_lastHeapPage = inc_firstHeapPage + inc_totalPages - 1;
!   new_firstHeapPage = MIN(firstHeapPage,
! 			  MIN(firstTablePage, inc_firstHeapPage));
!   new_lastHeapPage = MAX(lastHeapPage,
! 			 MAX(firstTablePage + tablePages - 1,
! 			     inc_lastHeapPage));
    new_totalPages = totalPages + tablePages + inc_totalPages;
    heapSpanPages = new_lastHeapPage - new_firstHeapPage + 1;
  
!   new_tablePages = (heapSpanPages*sizeof(int)*2 /* pageLink, pageHeap */
! 		    + heapSpanPages*sizeof(short)*2 /* pageSpace, pageGroup */
! 		    + heapSpanPages*wordsPerPage/bitsPerWord*bytesPerWord /* objectMap */
! #if !HEADER_SIZE || defined(MARKING)
! 		    + heapSpanPages*wordsPerPage/bitsPerWord*bytesPerWord /* liveMap */
! #endif
  		    + bytesPerPage - 1) / bytesPerPage;
    new_tables = ::new char[new_tablePages*bytesPerPage + bytesPerPage - 1];
    if (new_tables == NULL)
***************
*** 757,763 ****
  #     ifndef _WIN32
  	  set_new_handler(savedNewHandler);
  #     endif
!       if (inc_heap) ::delete inc_heap;
        expandFailed = true;
        WHEN_VERBOSE (CMM_STATS,
  		    fprintf(stderr, "\n***** CMM  Heap expansion failed\n"));
--- 744,750 ----
  #     ifndef _WIN32
  	  set_new_handler(savedNewHandler);
  #     endif
!       if (inc_heap) delete inc_heap;
        expandFailed = true;
        WHEN_VERBOSE (CMM_STATS,
  		    fprintf(stderr, "\n***** CMM  Heap expansion failed\n"));
***************
*** 768,779 ****
  # endif
    new_pageSpace = (short *)new_tables;
    new_pageGroup = &new_pageSpace[heapSpanPages];
!   new_pageLink = (Page *)&new_pageGroup[heapSpanPages];
    new_pageHeap = (CmmHeap **)&new_pageLink[heapSpanPages];
!   new_objectMap = (Word *)&new_pageHeap[heapSpanPages];
  #if !HEADER_SIZE || defined(MARKING)
    new_liveMap =
!     (Word *)&new_objectMap[heapSpanPages*wordsPerPage/bitsPerWord];
  #endif
  
    new_pageSpace = new_pageSpace - new_firstHeapPage;
--- 755,766 ----
  # endif
    new_pageSpace = (short *)new_tables;
    new_pageGroup = &new_pageSpace[heapSpanPages];
!   new_pageLink = (page *)&new_pageGroup[heapSpanPages];
    new_pageHeap = (CmmHeap **)&new_pageLink[heapSpanPages];
!   new_objectMap = (unsigned long *)&new_pageHeap[heapSpanPages];
  #if !HEADER_SIZE || defined(MARKING)
    new_liveMap =
!     (unsigned long *)&new_objectMap[heapSpanPages*wordsPerPage/bitsPerWord];
  #endif
  
    new_pageSpace = new_pageSpace - new_firstHeapPage;
***************
*** 785,790 ****
--- 772,797 ----
    new_liveMap = new_liveMap - WORD_INDEX(new_firstHeapPage*bytesPerPage);
  #endif
  
+   /* Recycle old tables */
+   page lastTablePage = firstTablePage + tablePages - 1;
+   for (i = firstTablePage; i <= lastTablePage; i++)
+     new_pageHeap[i] = NOHEAP;
+   /* Fill gaps */
+   page gapStart = MIN(lastTablePage, inc_lastHeapPage);
+   page gap1Start = MIN(lastHeapPage, gapStart);
+ 
+   page gapEnd = MAX(firstTablePage, inc_firstHeapPage);
+   page gap2End = MAX(firstHeapPage, gapEnd);
+ 
+   page gap1End = (gapEnd == gap2End) ?
+     MAX(firstHeapPage, MIN(firstTablePage, inc_firstHeapPage)) : gapEnd;
+   page gap2Start = (gapStart == gap1Start) ?
+     MIN(lastHeapPage, MAX(lastTablePage, inc_lastHeapPage)) : gapStart;
+   for (i = gap1Start + 1; i < gap1End; i++)
+     new_pageHeap[i] = UNCOLLECTEDHEAP;
+   for (i = gap2Start + 1; i < gap2End; i++)
+     new_pageHeap[i] = UNCOLLECTEDHEAP;
+ 
    /* Initialize new side tables */
    for (i = inc_firstHeapPage ; i <= inc_lastHeapPage ; i++)
      new_pageHeap[i] = NOHEAP;
***************
*** 796,802 ****
        new_pageGroup[i] = pageGroup[i];
      }
    for (i = WORD_INDEX(firstHeapPage*bytesPerPage);
!        i < WORD_INDEX((lastHeapPage + 1)*bytesPerPage); i++)
      {
        new_objectMap[i] = objectMap[i];
  #if !HEADER_SIZE || defined(MARKING)
--- 803,809 ----
        new_pageGroup[i] = pageGroup[i];
      }
    for (i = WORD_INDEX(firstHeapPage*bytesPerPage);
!        (unsigned)i < WORD_INDEX((lastHeapPage + 1)*bytesPerPage); i++)
      {
        new_objectMap[i] = objectMap[i];
  #if !HEADER_SIZE || defined(MARKING)
***************
*** 805,834 ****
  #endif
      }
  
-   if (recycleOldTables)
-     {
-       /* Recycle old tables */
-       for (i = firstTablePage; i <= lastTablePage; i++)
- 	new_pageHeap[i] = NOHEAP;
-       /* Fill gaps */
-       Page gapStart = MIN(lastTablePage, inc_lastHeapPage);
-       Page gap1Start = MIN(lastHeapPage, gapStart);
- 
-       Page gapEnd = MAX(firstTablePage, inc_firstHeapPage);
-       Page gap2End = MAX(firstHeapPage, gapEnd);
- 
-       Page gap1End = (gapEnd == gap2End) ?
- 	MAX(firstHeapPage, MIN(firstTablePage, inc_firstHeapPage)) : gapEnd;
-       Page gap2Start = (gapStart == gap1Start) ?
- 	MIN(lastHeapPage, MAX(lastTablePage, inc_lastHeapPage)) : gapStart;
-       for (i = gap1Start + 1; i < gap1End; i++)
- 	new_pageHeap[i] = UNCOLLECTEDHEAP;
-       for (i = gap2Start + 1; i < gap2End; i++)
- 	new_pageHeap[i] = UNCOLLECTEDHEAP;
-     }
-   else
-     ::delete (char *)(pageSpace + firstHeapPage); // address of old tables
- 
    pageSpace = new_pageSpace;
    pageLink = new_pageLink;
    pageGroup = new_pageGroup;
--- 812,817 ----
***************
*** 863,871 ****
   *---------------------------------------------------------------------------*/
  
  static void
! emptyStableSpace(Page end)
  {
!   Page scan;
    if (queueHead == 0)		// happens in test3
      return;
    end = pageLink[end];
--- 846,854 ----
   *---------------------------------------------------------------------------*/
  
  static void
! emptyStableSpace(page end)
  {
!   page scan;
    if (queueHead == 0)		// happens in test3
      return;
    end = pageLink[end];
***************
*** 894,900 ****
   *---------------------------------------------------------------------------*/
  
  static void
! queue(Page page)
  {
    if (queueHead != 0)
      pageLink[queueTail] = page;
--- 877,883 ----
   *---------------------------------------------------------------------------*/
  
  static void
! queue(int page)
  {
    if (queueHead != 0)
      pageLink[queueTail] = page;
***************
*** 917,923 ****
  void
  promotePage(GCP cp)
  {
!   Page page = GCPtoPage(cp);
  
    // Don't promote pages belonging to other heaps.
    // (We noticed no benefit by inlining the following test in the caller)
--- 900,906 ----
  void
  promotePage(GCP cp)
  {
!   page page = GCPtoPage(cp);
  
    // Don't promote pages belonging to other heaps.
    // (We noticed no benefit by inlining the following test in the caller)
***************
*** 927,934 ****
      {
  #     ifdef MARKING
        CmmObject *bp = basePointer(cp);
!       page = GCPtoPage(bp);
!       if (OUTSIDE_HEAPS(page))
  	return;
        MARK(bp);
  #     endif
--- 910,917 ----
      {
  #     ifdef MARKING
        CmmObject *bp = basePointer(cp);
!       unsigned bpp = GCPtoPage(bp);
!       if (OUTSIDE_HEAPS(bpp))
  	return;
        MARK(bp);
  #     endif
***************
*** 964,971 ****
  
    register int index 		= WORD_INDEX(fp);
    register int inner 		= BIT_INDEX(fp);
!   register Word mask	= 1 << inner;
!   register Word bits	= objectMap[index];
  
    do
      {
--- 947,954 ----
  
    register int index 		= WORD_INDEX(fp);
    register int inner 		= BIT_INDEX(fp);
!   register unsigned long mask	= 1 << inner;
!   register unsigned long bits	= objectMap[index];
  
    do
      {
***************
*** 1010,1016 ****
    int  page = GCPtoPage(cp);	/* Page number */
    GCP  np;			/* Pointer to the new object */
  # if HEADER_SIZE
!   Ptr  header;			/* Object header */
  # endif
  
    /* Verify that the object is a valid pointer and decrement ptr cnt */
--- 993,999 ----
    int  page = GCPtoPage(cp);	/* Page number */
    GCP  np;			/* Pointer to the new object */
  # if HEADER_SIZE
!   int  header;			/* Object header */
  # endif
  
    /* Verify that the object is a valid pointer and decrement ptr cnt */
***************
*** 1068,1074 ****
    SET_OBJECTMAP(np);
    freeWords = freeWords - words;
  # if HEADER_SIZE
!   cp[-HEADER_SIZE] = (Ptr)np;	// lowest bit 0 means forwarded
    words -= HEADER_SIZE;
    while (words--) *firstFreeWord++ = *cp++;
  #   ifdef DOUBLE_ALIGN
--- 1051,1057 ----
    SET_OBJECTMAP(np);
    freeWords = freeWords - words;
  # if HEADER_SIZE
!   cp[-HEADER_SIZE] = (int)np;	// lowest bit 0 means forwarded
    words -= HEADER_SIZE;
    while (words--) *firstFreeWord++ = *cp++;
  #   ifdef DOUBLE_ALIGN
***************
*** 1099,1111 ****
  DefaultHeap::scavenge(CmmObject **loc)
  {
    GCP pp = (GCP)*loc;
!   Page page = GCPtoPage(pp);
    if (!OUTSIDE_HEAPS(page))
      {
        GCP p = (GCP)basePointer((GCP)*loc);
        page = GCPtoPage(p);
  
!       if (inside(p))		// in this heap
  	{
  	  if (inFromSpace(page)) // can be moved
  	    *loc = (CmmObject *)((int)CmmMove(p) + (int)*loc - (int)p);
--- 1082,1094 ----
  DefaultHeap::scavenge(CmmObject **loc)
  {
    GCP pp = (GCP)*loc;
!   page page = GCPtoPage(pp);
    if (!OUTSIDE_HEAPS(page))
      {
        GCP p = (GCP)basePointer((GCP)*loc);
        page = GCPtoPage(p);
  
!       if (inside(p))	// in this heap
  	{
  	  if (inFromSpace(page)) // can be moved
  	    *loc = (CmmObject *)((int)CmmMove(p) + (int)*loc - (int)p);
***************
*** 1114,1129 ****
  	    {
  	      assert(inStableSpace(page) || pageSpace[page] == SCANNEDSPACE);
  	      MARK(p);
! 	      if (!(page == scanPage && p > scanPtr))
! 		// it is not further in the page being scanned
! 	        if (SCANNED(page) // or p was not traversed when page was scanned
! #                   if HEADER_SIZE
! 		    && HEADER_TAG(p[-HEADER_SIZE]) == OBJECT_TAG
! #                   endif
! 		    )
! 		  ((CmmObject *)p)->traverse();
  	    }
! #         endif			// MARKING
  	}
        else if (!OUTSIDE_HEAPS(page)
  	       // if page is OUTSIDE_HEAPS, p must be an ambiguous pointer
--- 1097,1110 ----
  	    {
  	      assert(inStableSpace(page) || pageSpace[page] == SCANNEDSPACE);
  	      MARK(p);
! 	      if (SCANNED(page)	// p was not traversed when page was scanned
! #                 if HEADER_SIZE
! 		  && HEADER_TAG(p[-HEADER_SIZE]) == OBJECT_TAG
! #                 endif
! 		  )
! 		((CmmObject *)p)->traverse();
  	    }
! #         endif // MARKING
  	}
        else if (!OUTSIDE_HEAPS(page)
  	       // if page is OUTSIDE_HEAPS, p must be an ambiguous pointer
***************
*** 1222,1236 ****
      CmmExamineStaticAreas(CmmExamineStaticArea);
  
      /* Examine registered roots:		*/
!     for (int i = 0; i < roots.count; i++)
        {
! 	fp = roots.entries[i].addr;
! 	for (int j = roots.entries[i].bytes; j > 0; j = j - bytesPerWord)
  	  promotePage((GCP)*fp++);
        }
- 
      /* Examine the uncollected heap:		*/
-     /* Should scan all opaque heaps		*/
      if (Cmm::flags & CMM_HEAPROOTS)
        {
  	WHEN_VERBOSE (CMM_HEAPLOG,
--- 1203,1215 ----
      CmmExamineStaticAreas(CmmExamineStaticArea);
  
      /* Examine registered roots:		*/
!     for (int i = 0; i < rootsCount; i++)
        {
! 	fp = roots[i].addr;
! 	for (int j = roots[i].bytes; j > 0; j = j - bytesPerWord)
  	  promotePage((GCP)*fp++);
        }
      /* Examine the uncollected heap:		*/
      if (Cmm::flags & CMM_HEAPROOTS)
        {
  	WHEN_VERBOSE (CMM_HEAPLOG,
***************
*** 1258,1271 ****
    // Sweep across stable pages and move their constituent items.
    page = queueHead;
    // pages promoted from here should survive this generation:
!   Page lastStable = queueTail;
    while (page)
      {
  #     ifdef MARKING		// pointers to unmarked objects within
        SET_SCANNED(page);	// this page will have to be traversed
- #      ifndef NO_SCAN_OPT
-       scanPage = page;
- #      endif
  #     endif			// recursively by scavenge
        cp = pageToGCP(page);
        WHEN_VERBOSE (CMM_DEBUGLOG, fprintf(stderr, "sweeping 0x%x\n", cp));
--- 1237,1247 ----
    // Sweep across stable pages and move their constituent items.
    page = queueHead;
    // pages promoted from here should survive this generation:
!   int lastStable = queueTail;
    while (page)
      {
  #     ifdef MARKING		// pointers to unmarked objects within
        SET_SCANNED(page);	// this page will have to be traversed
  #     endif			// recursively by scavenge
        cp = pageToGCP(page);
        WHEN_VERBOSE (CMM_DEBUGLOG, fprintf(stderr, "sweeping 0x%x\n", cp));
***************
*** 1286,1308 ****
  	      && MARKED(cp + HEADER_SIZE)
  #             endif
  	      )
! 	    {
! #             ifndef NO_SCAN_OPT
! 	      scanPtr = cp;
! #             endif
! 	      ((CmmObject *)(cp + HEADER_SIZE))->traverse();
! 	    }
  	  cp = cp + HEADER_WORDS(*cp);
  #         else
  #           ifdef MARKING
  	  if (MARKED(cp))
  #           endif
! 	    {
! #             ifndef NO_SCAN_OPT
! 	      scanPtr = cp;
! #             endif
! 	      ((CmmObject *)cp)->traverse();
! 	    }
  	  cp = cp + ((CmmObject *)cp)->words();
  #         endif
  	}
--- 1262,1274 ----
  	      && MARKED(cp + HEADER_SIZE)
  #             endif
  	      )
! 	    ((CmmObject *)(cp + HEADER_SIZE))->traverse();
  	  cp = cp + HEADER_WORDS(*cp);
  #         else
  #           ifdef MARKING
  	  if (MARKED(cp))
  #           endif
! 	    ((CmmObject *)cp)->traverse();
  	  cp = cp + ((CmmObject *)cp)->words();
  #         endif
  	}
***************
*** 1313,1319 ****
    {
      /* Restore scanned pages to STABLESPACE */
      Page scan = queueHead;
!     while (scan)
        {
  	pageSpace[scan] = STABLESPACE;
  	scan = pageLink[scan];
--- 1279,1285 ----
    {
      /* Restore scanned pages to STABLESPACE */
      Page scan = queueHead;
!     while (scan != lastStable)
        {
  	pageSpace[scan] = STABLESPACE;
  	scan = pageLink[scan];
***************
*** 1370,1377 ****
   *
   *---------------------------------------------------------------------------*/
  
! static inline Page
! nextPage(Page page)
  {
    return (page == lastHeapPage) ? firstHeapPage : page + 1;
  }
--- 1336,1343 ----
   *
   *---------------------------------------------------------------------------*/
  
! static inline page
! nextPage(page page)
  {
    return (page == lastHeapPage) ? firstHeapPage : page + 1;
  }
***************
*** 1391,1397 ****
  allocatePages(int pages, CmmHeap *heap)
  {
    int  	free;			/* # contiguous free pages */
!   Page	firstPage;		/* Page # of first free page */
    int	allPages;		/* # of pages in the heap */
    GCP	firstByte;		/* address of first free page */
  
--- 1357,1363 ----
  allocatePages(int pages, CmmHeap *heap)
  {
    int  	free;			/* # contiguous free pages */
!   int	firstPage;		/* Page # of first free page */
    int	allPages;		/* # of pages in the heap */
    GCP	firstByte;		/* address of first free page */
  
***************
*** 1428,1434 ****
   FOUND:
    // Ok, I found all needed contiguous pages.
    freePages -= pages;
-   heap->reservedPages += pages;
    firstByte = pageToGCP(firstPage);
    int i = 1;
    while (pages--)
--- 1394,1399 ----
***************
*** 1459,1465 ****
  GCP
  DefaultHeap::getPages(int pages)
  {
!   Page firstPage;		/* Page # of first free page	*/
  
  //#define NEW_GETPAGE bad: grows valla to 29063K
  #ifndef NEW_GETPAGE
--- 1424,1430 ----
  GCP
  DefaultHeap::getPages(int pages)
  {
!   page firstPage;		/* Page # of first free page	*/
  
  //#define NEW_GETPAGE bad: grows valla to 29063K
  #ifndef NEW_GETPAGE
***************
*** 1517,1523 ****
      firstFreeWord = allocatePages(reserved, this);
      firstUnusedPage = firstPage = GCPtoPage(firstFreeWord);
      int i = firstPage + reserved - 1;
!     lastReservedPage = MAX(lastReservedPage, (Page)i);
      for (i = pages; i < reserved; i++)
        pageSpace[firstPage + i] = UNALLOCATEDSPACE;
    }
--- 1482,1489 ----
      firstFreeWord = allocatePages(reserved, this);
      firstUnusedPage = firstPage = GCPtoPage(firstFreeWord);
      int i = firstPage + reserved - 1;
!     lastReservedPage = MAX(lastReservedPage, (page)i);
!     reservedPages += reserved;
      for (i = pages; i < reserved; i++)
        pageSpace[firstPage + i] = UNALLOCATEDSPACE;
    }
***************
*** 1573,1586 ****
  				    <= USED2FREE_RATIO * (freePages + reservedPages - usedPages - pages))
  
  GCP
! DefaultHeap::alloc(Word size)
  {
    GCP  object;			/* Pointer to the object */
  
    size = bytesToWords(size);	// add size of header
  
    /* Try to allocate from current page */
!   if (size <= (Word)freeWords)
      {
  #     if HEADER_SIZE
        object = firstFreeWord;
--- 1539,1552 ----
  				    <= USED2FREE_RATIO * (freePages + reservedPages - usedPages - pages))
  
  GCP
! DefaultHeap::alloc(unsigned long size)
  {
    GCP  object;			/* Pointer to the object */
  
    size = bytesToWords(size);	// add size of header
  
    /* Try to allocate from current page */
!   if (size <= (unsigned long)freeWords)
      {
  #     if HEADER_SIZE
        object = firstFreeWord;
***************
*** 1677,1687 ****
  {
    extern int end;
    if (
! #     ifdef _WIN32
!       printf("in text?\n") &&
! #     else
!       obj >= (void *)(&end) &&
! #     endif
  #     ifdef STACK_GROWS_DOWNWARD
        obj < (void *)(&obj)
  #     else
--- 1643,1653 ----
  {
    extern int end;
    if (
! #	  ifdef _WIN32
! 	  printf("in text?\n") &&
! #	  else
! 	  obj >= (void *)(&end) &&
! #	  endif
  #     ifdef STACK_GROWS_DOWNWARD
        obj < (void *)(&obj)
  #     else
***************
*** 1689,1695 ****
  #     endif
        )
      {
!       Page page = GCPtoPage(obj);
        if (OUTSIDE_HEAPS(page))
  	return false;
      }
--- 1655,1661 ----
  #     endif
        )
      {
!       page page = GCPtoPage(obj);
        if (OUTSIDE_HEAPS(page))
  	return false;
      }
***************
*** 1715,1732 ****
  
    return (void *)object;
  }
- 
  /*---------------------------------------------------------------------------*
   *
   * CmmObject::operator delete
   *
   *---------------------------------------------------------------------------*/
- 
  void CmmObject::operator delete(void *obj)
  {
    (((CmmObject *)obj)->heap())->reclaim((GCP)obj);
  }
  
  /*---------------------------------------------------------------------------*
   *
   * CmmVarObject::operator new
--- 1681,1718 ----
  
    return (void *)object;
  }
  /*---------------------------------------------------------------------------*
   *
   * CmmObject::operator delete
   *
   *---------------------------------------------------------------------------*/
  void CmmObject::operator delete(void *obj)
  {
    (((CmmObject *)obj)->heap())->reclaim((GCP)obj);
  }
  
+ #ifndef _WIN32
+ /*---------------------------------------------------------------------------*
+  *
+  * CmmObject::operator new[]
+  *
+  *---------------------------------------------------------------------------*/
+ void *
+ CmmObject::operator new[](size_t size, CmmHeap *heap)
+ {
+   return sizeof(CmmVarObject) + (char*) (new(size, heap) CmmVarObject);
+ }
+ /*---------------------------------------------------------------------------*
+  *
+  * CmmObject::operator delete[]
+  *
+  *---------------------------------------------------------------------------*/
+ void
+ CmmObject::operator delete[](void* obj)
+ {
+   delete obj;
+ }
+ #endif				// _WIN32
  /*---------------------------------------------------------------------------*
   *
   * CmmVarObject::operator new
***************
*** 1736,1744 ****
  void *
  CmmVarObject::operator new(size_t size, size_t extraSize, CmmHeap *heap)
  {
!   GCP object = heap->alloc(size + extraSize);
  
!   // To avoid problems in GC after new() but during constructor
    *object = *((GCP)aCmmVarObject);
  
    return (void *)object;
--- 1722,1732 ----
  void *
  CmmVarObject::operator new(size_t size, size_t extraSize, CmmHeap *heap)
  {
!   size += extraSize;
  
!   GCP object = heap->alloc(size);
! 
!   // To avoid problems in GC after new but during constructor
    *object = *((GCP)aCmmVarObject);
  
    return (void *)object;
***************
*** 1785,1791 ****
  static void
  verifyObject(GCP cp, bool old)
  {
!   Page  page = GCPtoPage(cp);
    GCP  xp = pageToGCP(page);	/* Ptr to start of page */
    int  error = 0;
  
--- 1773,1779 ----
  static void
  verifyObject(GCP cp, bool old)
  {
!   page  page = GCPtoPage(cp);
    GCP  xp = pageToGCP(page);	/* Ptr to start of page */
    int  error = 0;
  
***************
*** 1831,1837 ****
  # else
    int  size = ((CmmObject *)cp)->words();
  # endif
!   Page pagen = GCPtoPage(cp);
    int error = 0;
  
    if  FORWARDED(cp[-HEADER_SIZE])  goto fail;
--- 1819,1825 ----
  # else
    int  size = ((CmmObject *)cp)->words();
  # endif
!   page pagen = GCPtoPage(cp);
    int error = 0;
  
    if  FORWARDED(cp[-HEADER_SIZE])  goto fail;
***************
*** 1850,1856 ****
      int pages = pageGroup[page];
      if (pages < 0) pages = pageGroup[page+pages];
  #   endif
!     Page pagex = pagen;
      while (--pages)  {
        pagex++;
        if (pagex > lastHeapPage  ||
--- 1838,1844 ----
      int pages = pageGroup[page];
      if (pages < 0) pages = pageGroup[page+pages];
  #   endif
!     page pagex = pagen;
      while (--pages)  {
        pagex++;
        if (pagex > lastHeapPage  ||
***************
*** 1883,1889 ****
  static void
  logRoot(long* fp)
  {
!   Page  page = GCPtoPage(fp);
  
    if (page < firstHeapPage
        || page > lastHeapPage
--- 1871,1877 ----
  static void
  logRoot(long* fp)
  {
!   page  page = GCPtoPage(fp);
  
    if (page < firstHeapPage
        || page > lastHeapPage
***************
*** 1922,1935 ****
  
  
  /*---------------------------------------------------------------------------*
!  * -- UncollectedHeap::scanRoots(Page page)
   *
   * Promotes pages referred by any allocated object inside "page".
   * (Should be) Used by DefaultHeap to identify pointers from UncollectedHeap.
   *
   *---------------------------------------------------------------------------*/
  void
! UncollectedHeap::scanRoots(Page page)
  {
    GCP start = pageToGCP(page);
    GCP end = pageToGCP(page + 1);
--- 1910,1923 ----
  
  
  /*---------------------------------------------------------------------------*
!  * -- UncollectedHeap::scanRoots(int page)
   *
   * Promotes pages referred by any allocated object inside "page".
   * (Should be) Used by DefaultHeap to identify pointers from UncollectedHeap.
   *
   *---------------------------------------------------------------------------*/
  void
! UncollectedHeap::scanRoots(page page)
  {
    GCP start = pageToGCP(page);
    GCP end = pageToGCP(page + 1);
Only in /project/posso/cmm/curr/cmm: cmm.cpp.orig
Only in /project/posso/cmm/curr/cmm: cmm.cpp.rej
Only in /project/posso/cmm/curr/cmm: cmm.cpp.rej.orig
diff -c /home/omega/attardi/posso/cmm/cmm.h /project/posso/cmm/curr/cmm/cmm.h
*** /home/omega/attardi/posso/cmm/cmm.h	Wed Feb 26 12:09:06 1997
--- /project/posso/cmm/curr/cmm/cmm.h	Tue Feb 25 23:00:46 1997
***************
*** 132,157 ****
  
     Arrays of collected objects
     ---------------------------
!    Class CmmArray can be used to create arrays of CmmObject's as follows.
!    To create an array of objects of class Item, overload the new() operator
!    for class Item:
!   
!   	void*
!   	Item::operator new[](size_t size)
!   	{
!   	  return sizeof(size_t) + (char*)new(size) CmmArray<Item>;
!   	}
!   
!    Then you can create arrays of Item normally, for instance:
!   
!   	Item* anArrayOfItems = new Item[20];
!   
!    The constructor for class Item with no argument will be called for
!    each Item in the array.
!    Such arrays can be used normally, e.g.:
!   
!   	anArrayOfItems[i].print();
!   	Item anItem = anArrayOfItems[3];
  
     Caveats
     -------
--- 132,142 ----
  
     Arrays of collected objects
     ---------------------------
!    Garbage collected arrays of garbage collected objects can be created
!    by using class CmmArray.
!    Such arrays must be always used through references, e.g.:
! 
! 	CmmArray<MyClass> & MyVector = * new (100) CmmArray<MyClass>;
  
     Caveats
     -------
***************
*** 169,175 ****
     Pointers to garbage collected objects MAY NOT be stored in dynamically
     allocated objects that are not garbage collected, UNLESS one has specified
     the CMM_HEAPROOTS flag in a Cmm declaration, OR declared that region as
!    a root via a call to registerRootArea().
  
     Pointers to garbage collected objects contained in garbage collected objects
     MUST always point outside the garbage collected heap or to a garbage
--- 154,160 ----
     Pointers to garbage collected objects MAY NOT be stored in dynamically
     allocated objects that are not garbage collected, UNLESS one has specified
     the CMM_HEAPROOTS flag in a Cmm declaration, OR declared that region as
!    a root via a call to gcRoots.
  
     Pointers to garbage collected objects contained in garbage collected objects
     MUST always point outside the garbage collected heap or to a garbage
***************
*** 363,368 ****
--- 348,363 ----
  #define VirtualBase(A) &(P ## A)
  #endif
  
+ /*---------------------------------------------------------------------------*
+  *
+  * Additional roots may be registered with the garbage collector by calling
+  * the procedure gcRoots with a pointer to the area and the size of the area.
+  *
+  *---------------------------------------------------------------------------*/
+ 
+ extern void  gcRoots(void *area, int bytes);
+ extern void  gcUnroots(void *addr);
+ 
  /* Verbosity levels:							*/
  const	CMM_STATS    =   1;	/* Log garbage collector info		*/
  const	CMM_ROOTLOG  =   2;	/* Log roots found in registers, stack
***************
*** 386,397 ****
  
  #if HEADER_SIZE
  #define MAKE_TAG(index) ((index) << 21 | 1)
! #define MAKE_HEADER(words, tag) (Ptr)((tag) | (words) << 1)
  
! #define HEADER_TAG(header) ((Word)(header) >> 21 & 0x7FF)
! #define HEADER_WORDS(header) ((Word)(header) >> 1 & 0xFFFFF) // includes HEADER_SIZE
  #define maxHeaderWords 0xFFFFF		/* 1048575 = 4,194,300 bytes */
! #define FORWARDED(header) (((Word)(header) & 1) == 0)
  #else
  /* an object is forwarded if it is marked as live and contained in FromSpace */
  #define FORWARDED(gcp) ((MARKED(gcp) && inFromSpace(GCPtoPage(gcp))))
--- 381,392 ----
  
  #if HEADER_SIZE
  #define MAKE_TAG(index) ((index) << 21 | 1)
! #define MAKE_HEADER(words, tag) ((tag) | (words) << 1)
  
! #define HEADER_TAG(header) ((header) >> 21 & 0x7FF)
! #define HEADER_WORDS(header) ((header) >> 1 & 0xFFFFF) // includes HEADER_SIZE
  #define maxHeaderWords 0xFFFFF		/* 1048575 = 4,194,300 bytes */
! #define FORWARDED(header) (((header) & 1) == 0)
  #else
  /* an object is forwarded if it is marked as live and contained in FromSpace */
  #define FORWARDED(gcp) ((MARKED(gcp) && inFromSpace(GCPtoPage(gcp))))
***************
*** 415,432 ****
   * object and an offset.
   */
  
! extern Page	firstHeapPage;	/* Page # of first heap page		*/
! extern Page	lastHeapPage;	/* Page # of last heap page		*/
! extern Page	firstFreePage;	/* First possible free page		*/
! extern Word *objectMap; /* Bitmap of 1st words of user objects	*/
  #if !HEADER_SIZE || defined(MARKING)
! extern Word *liveMap;	/* Bitmap of objects reached during GC	*/
  #endif
  extern short *pageSpace;	/* Space number for each page		*/
  extern short *pageGroup;	/* Size of group of pages		*/
! extern Page  *pageLink;		/* Page link for each page		*/
  extern CmmHeap **pageHeap;	/* Heap to which each page belongs	*/
  extern int   tablePages;	/* # of pages used by tables		*/
  extern int   freePages;		/* # of pages not yet allocated		*/
  
  
--- 410,428 ----
   * object and an offset.
   */
  
! extern page	firstHeapPage;	/* Page # of first heap page		*/
! extern page	lastHeapPage;	/* Page # of last heap page		*/
! extern page	firstFreePage;	/* First possible free page		*/
! extern unsigned long *objectMap; /* Bitmap of 1st words of user objects	*/
  #if !HEADER_SIZE || defined(MARKING)
! extern unsigned long *liveMap;	/* Bitmap of objects reached during GC	*/
  #endif
  extern short *pageSpace;	/* Space number for each page		*/
  extern short *pageGroup;	/* Size of group of pages		*/
! extern page  *pageLink;		/* Page link for each page		*/
  extern CmmHeap **pageHeap;	/* Heap to which each page belongs	*/
  extern int   tablePages;	/* # of pages used by tables		*/
+ extern page  firstTablePage;	/* index of first page used by table	*/
  extern int   freePages;		/* # of pages not yet allocated		*/
  
  
***************
*** 465,472 ****
  
  /* Page number <--> pointer conversion */
  
! #define pageToGCP(p) ((GCP)(((Word)p)*bytesPerPage))
! #define GCPtoPage(p) (((Word)p)/bytesPerPage)
  
  /* The following define is used to compute the number of words needed for
   * an object.
--- 461,468 ----
  
  /* Page number <--> pointer conversion */
  
! #define pageToGCP(p) ((GCP)(((unsigned long)p)*bytesPerPage))
! #define GCPtoPage(p) (((unsigned long)p)/bytesPerPage)
  
  /* The following define is used to compute the number of words needed for
   * an object.
***************
*** 545,551 ****
    static CmmHeap *heap;
    static CmmHeap *theMSHeap;
    static char*  version;
!   static int  verbose;
    static int  minHeap;		/* # of bytes of initial heap	*/
    static int  maxHeap;		/* # of bytes of the final heap */
    static int  incHeap;		/* # of bytes of each increment */
--- 541,547 ----
    static CmmHeap *heap;
    static CmmHeap *theMSHeap;
    static char*  version;
!   static int verbose;
    static int  minHeap;		/* # of bytes of initial heap	*/
    static int  maxHeap;		/* # of bytes of the final heap */
    static int  incHeap;		/* # of bytes of each increment */
***************
*** 569,581 ****
  
    CmmHeap()
      {
-       reservedPages = 0;
        opaque = false;
      }
  
!   virtual GCP   alloc(Word) = 0;
    virtual void  reclaim(GCP) {};
!   virtual void  scanRoots(int) {};
  
    virtual void collect()
      {
--- 565,576 ----
  
    CmmHeap()
      {
        opaque = false;
      }
  
!   virtual GCP   alloc(unsigned long) = 0;
    virtual void  reclaim(GCP) {};
!   virtual void  scanRoots (int) {};
  
    virtual void collect()
      {
***************
*** 586,592 ****
  
    inline bool inside(GCP ptr)
      {
!       Page page = GCPtoPage(ptr); // Page number
        return (page >= firstHeapPage && page <= lastHeapPage
  	      && pageHeap[page] == this);
      }
--- 581,587 ----
  
    inline bool inside(GCP ptr)
      {
!       page page = GCPtoPage(ptr); /* Page number */
        return (page >= firstHeapPage && page <= lastHeapPage
  	      && pageHeap[page] == this);
      }
***************
*** 598,604 ****
  
    int reservedPages;		// pages reserved for this heap
  
!  protected:
    bool opaque;			// controls whether collectors for other heaps
  				// should traverse this heap
  };
--- 593,599 ----
  
    int reservedPages;		// pages reserved for this heap
  
!  private:
    bool opaque;			// controls whether collectors for other heaps
  				// should traverse this heap
  };
***************
*** 614,631 ****
  {
  public:
  
!   UncollectedHeap()
!     {
!       opaque = true;
!     }
! 
!   GCP alloc(Word size) { return (GCP)malloc(size); }
  
    void reclaim(GCP ptr) { free(ptr); }
!   void scanRoots	(Page page);
  };
  
  
  /*---------------------------------------------------------------------------*
   *
   * -- The DefaultHeap
--- 609,624 ----
  {
  public:
  
!   GCP alloc(unsigned long size) { return (GCP)malloc(size); }
  
    void reclaim(GCP ptr) { free(ptr); }
!   void scanRoots	(page page);
  };
  
  
+ CmmObject *basePointer(GCP);
+ 
+ 
  /*---------------------------------------------------------------------------*
   *
   * -- The DefaultHeap
***************
*** 637,643 ****
  public:
  
    DefaultHeap();
!   GCP alloc(Word);
    void reclaim(GCP) {}		// Bartlett's delete does nothing.
    void collect();		// the default garbarge collector
    void scavenge(CmmObject **ptr);
--- 630,636 ----
  public:
  
    DefaultHeap();
!   GCP alloc(unsigned long);
    void reclaim(GCP) {}		// Bartlett's delete does nothing.
    void collect();		// the default garbarge collector
    void scavenge(CmmObject **ptr);
***************
*** 648,659 ****
    Page firstUnusedPage;		// where to start looking for unused pages
    Page firstReservedPage;	// first page used by this Heap
    Page lastReservedPage;	// last page used by this Heap
- 
- #ifndef NO_SCAN_OPT
- private:
-   Page scanPage;		// page being scanned
-   GCP scanPtr;			// point reached in scanning scanPage
- #endif
  };
  
  /*---------------------------------------------------------------------------*
--- 641,646 ----
***************
*** 667,696 ****
  
   public:
  
!   MarkAndSweep();
!   inline GCP 		alloc	(Word size)
    					       { return (GCP) mswAlloc(size); }
    inline void 		reclaim	(GCP p)        { mswFree(p); }
    inline void 		collect	()	       { mswCollect(); }
!   inline void*		realloc (void * p, Word size)
                                { return mswRealloc(p, size); }
!   inline void*		calloc  (Word n, Word size)
    			      { return mswCalloc(n, size); }
  
    inline void		checkHeap()		{ mswCheckHeap(1); }
    inline void		showInfo()		{ mswShowInfo(); }
  
    void			tempHeapStart ()	{ mswTempHeapStart(); }
    void			tempHeapEnd   ()	{ mswTempHeapEnd(); }
    void			tempHeapFree  ()	{ mswTempHeapFree(); }
  
!   void			scanRoots(Page page);
  
  };
  
  /*---------------------------------------------------------------------------*
   *
!  * -- CmmObject
   *
   *---------------------------------------------------------------------------*/
  
--- 654,689 ----
  
   public:
  
!   inline GCP 		alloc	(unsigned long size)
    					       { return (GCP) mswAlloc(size); }
    inline void 		reclaim	(GCP p)        { mswFree(p); }
    inline void 		collect	()	       { mswCollect(); }
!   inline void*		realloc (void * p, unsigned long size)
                                { return mswRealloc(p, size); }
!   inline void*		calloc  (unsigned long n, unsigned long size)
    			      { return mswCalloc(n, size); }
  
    inline void		checkHeap()		{ mswCheckHeap(1); }
    inline void		showInfo()		{ mswShowInfo(); }
  
+   MarkAndSweep()
+     {
+       mswInit();
+     }
+ 
    void			tempHeapStart ()	{ mswTempHeapStart(); }
    void			tempHeapEnd   ()	{ mswTempHeapEnd(); }
    void			tempHeapFree  ()	{ mswTempHeapFree(); }
+   void			tempHeapRegisterRoot (void* ptr)
+   					{ mswRegisterRoot(ptr); }
  
!   void			scanRoots(page page);
  
  };
  
  /*---------------------------------------------------------------------------*
   *
!  * -- CmmObjects
   *
   *---------------------------------------------------------------------------*/
  
***************
*** 715,721 ****
  #ifdef MARKING
    inline void mark() { MARK(this); }
  
!   inline bool marked() { return (MARKED(this)); }
  #endif
  
    inline int forwarded()
--- 708,714 ----
  #ifdef MARKING
    inline void mark() { MARK(this); }
  
!   inline bool isMarked() { return (MARKED(this)); }
  #endif
  
    inline int forwarded()
***************
*** 732,738 ****
  #if !HEADER_SIZE
        MARK(this);
  #endif
!       ((GCP)this)[-HEADER_SIZE] = (Ptr)ptr;
      }
    inline CmmObject *getForward()
      {
--- 725,731 ----
  #if !HEADER_SIZE
        MARK(this);
  #endif
!       ((GCP)this)[-HEADER_SIZE] = (int)ptr;
      }
    inline CmmObject *getForward()
      {
***************
*** 749,762 ****
  #endif
  };
  
- /*---------------------------------------------------------------------------*
-  *
-  * -- CmmVarObject
-  *
-  * Collectable objects of variable size.
-  *
-  *---------------------------------------------------------------------------*/
- 
  class CmmVarObject: public CmmObject
  {
  public:
--- 742,747 ----
***************
*** 767,772 ****
--- 752,777 ----
   *
   * -- Arrays of CmmObjects
   *
+  * Class CmmArray can be used to create arrays of CmmObject's as follows.
+  * To create an array of objects of class Item, overload the new() operator
+  * for class Item:
+  *
+  *	void*
+  *	Item::operator new[](size_t size)
+  *	{
+  *	  return sizeof(size_t) + (char*)new(size) CmmArray<Item>;
+  *	}
+  *
+  * Then you can create and use array of Item normally, for instance:
+  *
+  *	Item* anArrayOfItems = new Item[20];
+  *
+  * The constructor for class Item with no argument will be called for
+  * each Item in the array.
+  *
+  *	anArrayOfItems[i].print();
+  *	Item anItem = anArrayOfItems[3];
+  *
   *---------------------------------------------------------------------------*/
  
  template <class T>
***************
*** 790,814 ****
  
    void traverse()
      {
!       for (size_t i = 0; i < count; i++)
! 	ptr[i].traverse();
      }
  
  private:
!   size_t count;			// the __GNUC__ initializes it after new[]
! #ifdef DOUBLE_ALIGN
!   size_t padding;
! #endif
!   T ptr[0];			// avoid call to T constructor
  };
  
  /*---------------------------------------------------------------------------*/
  
  inline void CmmHeap::
! visit(CmmObject* ptr)
  {
  #ifdef MARKING
!   if (!ptr->marked())
      {
        ptr->mark();
        ptr->traverse();
--- 795,817 ----
  
    void traverse()
      {
!       unsigned int count = ((size() - sizeof(CmmArray)) / sizeof(T)) + 1;
!       for (unsigned int i = 0; i < count; i++)
! 	if (((int*)ptr)[i])
! 	  ptr[i].traverse();
      }
  
  private:
!   T ptr[1];
  };
  
  /*---------------------------------------------------------------------------*/
  
  inline void CmmHeap::
! visit(CmmObject *ptr)
  {
  #ifdef MARKING
!   if (!ptr->isMarked())
      {
        ptr->mark();
        ptr->traverse();
***************
*** 818,826 ****
  #endif
  }
  
- CmmObject *basePointer(GCP);
- 
- 
  /*---------------------------------------------------------------------------*
   *
   * -- Library initialization
--- 821,826 ----
***************
*** 844,849 ****
--- 844,850 ----
  	Cmm::heap = Cmm::theDefaultHeap;
        }
      }
+   ~_CmmInit() {};		// destroy _DummyCmmInit after loading cmm.h
  };
  
  /*---------------------------------------------------------------------------*
***************
*** 854,945 ****
  #define GcVarObject	CmmVarObject
  #define GcArray		CmmArray
  
- 
- /*---------------------------------------------------------------------------*
-  *
-  * -- Set
-  *
-  *---------------------------------------------------------------------------*/
- 
- template <class T>
- class Set
- {
-  public:
-   Set()
-     {
-       last = 0;
-       max = 0;
-       free = 0;
-       iter = 0;
-     }
- 
-   void insert(T* entry)
-     {
- #     define	    setIncrement 10
- 
-       if (free)
- 	{
- 	  for (int i = 0; i < last; i++)
- 	    if (entries[i] == NULL)
- 	      {
- 		entries[i] = entry;
- 		free--;
- 		return;
- 	      }
- 	}
-       if (last == max)
- 	{
- 	  T** np;
- 	  int i;
- 	  max += setIncrement;
- 	  np = new T*[max];
- 	  for (i = 0; i < last; i++)
- 	    np[i] = entries[i];
- 	  delete  entries;
- 	  entries = np;
- 	  // clear the rest
- 	  for (; i < max; i++)
- 	    entries[i] = NULL;
- 	}
-       entries[last++] = entry;
-     }
- 
-   void erase(T* entry)
-     {
-       int i;
- 
-       for (i = 0; i < last; i++)
- 	if (entries[i] == entry)
- 	  {
- 	    entries[i] = NULL;
- 	    free++;
- 	    return;
- 	  }
-       assert(i < last);
-     }
- 
-   T* get()
-     {
-       // look for a non empty entry
-       while (iter < max)
- 	{
- 	  if (entries[iter])
- 	    return entries[iter++];
- 	  else
- 	    iter++;
- 	}
-       // No more entries;
-       return (T*)NULL;
-     }
- 
-   void begin() { iter = 0;}
- 
-   int  last;
-   T**  entries;
-   
- private:
-   int  max;
-   int  free;
-   int  iter;
- };
  #endif				// _CMM_H
--- 855,858 ----
Only in /project/posso/cmm/curr/cmm: cmm.h.orig
Only in /project/posso/cmm/curr/cmm: cmm.h.rej
Only in /project/posso/cmm/curr/cmm: cmm.h.rej.orig
diff -c /home/omega/attardi/posso/cmm/cmm.mak /project/posso/cmm/curr/cmm/cmm.mak
*** /home/omega/attardi/posso/cmm/cmm.mak	Wed Dec 18 20:19:04 1996
--- /project/posso/cmm/curr/cmm/cmm.mak	Tue Feb 25 23:00:47 1997
***************
*** 11,19 ****
  
  !IF "$(CFG)" != "cmm - Win32 Release" && "$(CFG)" != "cmm - Win32 Debug" &&\
   "$(CFG)" != "lib - Win32 Release" && "$(CFG)" != "lib - Win32 Debug" &&\
!  "$(CFG)" != "test2 - Win32 Debug" && "$(CFG)" != "test3 - Win32 Debug" &&\
!  "$(CFG)" != "test4 - Win32 Debug" && "$(CFG)" != "test5 - Win32 Debug" &&\
!  "$(CFG)" != "test6 - Win32 Debug"
  !MESSAGE Invalid configuration "$(CFG)" specified.
  !MESSAGE You can specify a configuration when running NMAKE on this makefile
  !MESSAGE by defining the macro CFG on the command line.  For example:
--- 11,21 ----
  
  !IF "$(CFG)" != "cmm - Win32 Release" && "$(CFG)" != "cmm - Win32 Debug" &&\
   "$(CFG)" != "lib - Win32 Release" && "$(CFG)" != "lib - Win32 Debug" &&\
!  "$(CFG)" != "test2 - Win32 Release" && "$(CFG)" != "test2 - Win32 Debug" &&\
!  "$(CFG)" != "test3 - Win32 Release" && "$(CFG)" != "test3 - Win32 Debug" &&\
!  "$(CFG)" != "test4 - Win32 Release" && "$(CFG)" != "test4 - Win32 Debug" &&\
!  "$(CFG)" != "test5 - Win32 Release" && "$(CFG)" != "test5 - Win32 Debug" &&\
!  "$(CFG)" != "test6 - Win32 Release" && "$(CFG)" != "test6 - Win32 Debug"
  !MESSAGE Invalid configuration "$(CFG)" specified.
  !MESSAGE You can specify a configuration when running NMAKE on this makefile
  !MESSAGE by defining the macro CFG on the command line.  For example:
***************
*** 26,35 ****
--- 28,42 ----
  !MESSAGE "cmm - Win32 Debug" (based on "Win32 (x86) Static Library")
  !MESSAGE "lib - Win32 Release" (based on "Win32 (x86) Static Library")
  !MESSAGE "lib - Win32 Debug" (based on "Win32 (x86) Static Library")
+ !MESSAGE "test2 - Win32 Release" (based on "Win32 (x86) Console Application")
  !MESSAGE "test2 - Win32 Debug" (based on "Win32 (x86) Console Application")
+ !MESSAGE "test3 - Win32 Release" (based on "Win32 (x86) Console Application")
  !MESSAGE "test3 - Win32 Debug" (based on "Win32 (x86) Console Application")
+ !MESSAGE "test4 - Win32 Release" (based on "Win32 (x86) Console Application")
  !MESSAGE "test4 - Win32 Debug" (based on "Win32 (x86) Console Application")
+ !MESSAGE "test5 - Win32 Release" (based on "Win32 (x86) Console Application")
  !MESSAGE "test5 - Win32 Debug" (based on "Win32 (x86) Console Application")
+ !MESSAGE "test6 - Win32 Release" (based on "Win32 (x86) Console Application")
  !MESSAGE "test6 - Win32 Debug" (based on "Win32 (x86) Console Application")
  !MESSAGE 
  !ERROR An invalid configuration is specified.
***************
*** 42,48 ****
  !ENDIF 
  ################################################################################
  # Begin Project
! # PROP Target_Last_Scanned "test3 - Win32 Debug"
  
  !IF  "$(CFG)" == "cmm - Win32 Release"
  
--- 49,55 ----
  !ENDIF 
  ################################################################################
  # Begin Project
! # PROP Target_Last_Scanned "cmm - Win32 Debug"
  
  !IF  "$(CFG)" == "cmm - Win32 Release"
  
***************
*** 59,65 ****
  OUTDIR=.\Release
  INTDIR=.\Release
  
! ALL : "lib - Win32 Release" 
  
  CLEAN : 
  	-@erase 
--- 66,73 ----
  OUTDIR=.\Release
  INTDIR=.\Release
  
! ALL : "test6 - Win32 Release" "test5 - Win32 Release" "test4 - Win32 Release"\
!  "test3 - Win32 Release" "test2 - Win32 Release" "lib - Win32 Release" 
  
  CLEAN : 
  	-@erase 
***************
*** 185,193 ****
  CLEAN : 
  	-@erase ".\Release\cmm.lib"
  	-@erase ".\Release\memory.obj"
- 	-@erase ".\Release\tempheap.obj"
  	-@erase ".\Release\cmm.obj"
  	-@erase ".\Release\msw.obj"
  
  "$(OUTDIR)" :
      if not exist "$(OUTDIR)/$(NULL)" mkdir "$(OUTDIR)"
--- 193,201 ----
  CLEAN : 
  	-@erase ".\Release\cmm.lib"
  	-@erase ".\Release\memory.obj"
  	-@erase ".\Release\cmm.obj"
  	-@erase ".\Release\msw.obj"
+ 	-@erase ".\Release\tempheap.obj"
  
  "$(OUTDIR)" :
      if not exist "$(OUTDIR)/$(NULL)" mkdir "$(OUTDIR)"
***************
*** 196,202 ****
  # ADD BASE CPP /nologo /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_WINDOWS" /YX /c
  # ADD CPP /nologo /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_WINDOWS" /YX /c
  CPP_PROJ=/nologo /ML /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_WINDOWS"\
!  /Fp"$(INTDIR)/lib.pch" /YX /Fo"$(INTDIR)/" /c 
  CPP_OBJS=.\Release/
  CPP_SBRS=
  
--- 204,210 ----
  # ADD BASE CPP /nologo /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_WINDOWS" /YX /c
  # ADD CPP /nologo /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_WINDOWS" /YX /c
  CPP_PROJ=/nologo /ML /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_WINDOWS"\
!  /Fp"$(INTDIR)/cmm.pch" /YX /Fo"$(INTDIR)/" /c 
  CPP_OBJS=.\Release/
  CPP_SBRS=
  
***************
*** 229,255 ****
  LIB32_FLAGS=/nologo /out:"$(OUTDIR)/cmm.lib" 
  LIB32_OBJS= \
  	"$(INTDIR)/memory.obj" \
- 	"$(INTDIR)/tempheap.obj" \
  	"$(INTDIR)/cmm.obj" \
! 	"$(INTDIR)/msw.obj"
  
  "$(OUTDIR)\cmm.lib" : "$(OUTDIR)" $(DEF_FILE) $(LIB32_OBJS)
      $(LIB32) @<<
    $(LIB32_FLAGS) $(DEF_FLAGS) $(LIB32_OBJS)
  <<
  
! !ELSEIF  "$(CFG)" == "lib - Win32 Debug"
  
  # PROP BASE Use_MFC 0
  # PROP BASE Use_Debug_Libraries 1
! # PROP BASE Output_Dir "lib\Debug"
! # PROP BASE Intermediate_Dir "lib\Debug"
! # PROP BASE Target_Dir "lib"
  # PROP Use_MFC 0
  # PROP Use_Debug_Libraries 1
  # PROP Output_Dir "Debug"
  # PROP Intermediate_Dir "Debug"
! # PROP Target_Dir "lib"
  OUTDIR=.\Debug
  INTDIR=.\Debug
  
--- 237,263 ----
  LIB32_FLAGS=/nologo /out:"$(OUTDIR)/cmm.lib" 
  LIB32_OBJS= \
  	"$(INTDIR)/memory.obj" \
  	"$(INTDIR)/cmm.obj" \
! 	"$(INTDIR)/msw.obj" \
! 	"$(INTDIR)/tempheap.obj"
  
  "$(OUTDIR)\cmm.lib" : "$(OUTDIR)" $(DEF_FILE) $(LIB32_OBJS)
      $(LIB32) @<<
    $(LIB32_FLAGS) $(DEF_FLAGS) $(LIB32_OBJS)
  <<
  
! !ELSEIF  "$(CFG)" == "cmm - Win32 Debug"
  
  # PROP BASE Use_MFC 0
  # PROP BASE Use_Debug_Libraries 1
! # PROP BASE Output_Dir "cmm___Wi"
! # PROP BASE Intermediate_Dir "cmm___Wi"
! # PROP BASE Target_Dir ""
  # PROP Use_MFC 0
  # PROP Use_Debug_Libraries 1
  # PROP Output_Dir "Debug"
  # PROP Intermediate_Dir "Debug"
! # PROP Target_Dir ""
  OUTDIR=.\Debug
  INTDIR=.\Debug
  
***************
*** 258,266 ****
  CLEAN : 
  	-@erase ".\Debug\cmm.lib"
  	-@erase ".\Debug\memory.obj"
  	-@erase ".\Debug\cmm.obj"
  	-@erase ".\Debug\msw.obj"
- 	-@erase ".\Debug\tempheap.obj"
  
  "$(OUTDIR)" :
      if not exist "$(OUTDIR)/$(NULL)" mkdir "$(OUTDIR)"
--- 266,274 ----
  CLEAN : 
  	-@erase ".\Debug\cmm.lib"
  	-@erase ".\Debug\memory.obj"
+ 	-@erase ".\Debug\tempheap.obj"
  	-@erase ".\Debug\cmm.obj"
  	-@erase ".\Debug\msw.obj"
  
  "$(OUTDIR)" :
      if not exist "$(OUTDIR)/$(NULL)" mkdir "$(OUTDIR)"
***************
*** 269,275 ****
  # ADD BASE CPP /nologo /W3 /GX /Z7 /Od /D "WIN32" /D "_DEBUG" /D "_WINDOWS" /YX /c
  # ADD CPP /nologo /W3 /GX /Z7 /Od /D "WIN32" /D "_DEBUG" /D "_WINDOWS" /YX /c
  CPP_PROJ=/nologo /MLd /W3 /GX /Z7 /Od /D "WIN32" /D "_DEBUG" /D "_WINDOWS"\
!  /Fp"$(INTDIR)/lib.pch" /YX /Fo"$(INTDIR)/" /c 
  CPP_OBJS=.\Debug/
  CPP_SBRS=
  
--- 277,283 ----
  # ADD BASE CPP /nologo /W3 /GX /Z7 /Od /D "WIN32" /D "_DEBUG" /D "_WINDOWS" /YX /c
  # ADD CPP /nologo /W3 /GX /Z7 /Od /D "WIN32" /D "_DEBUG" /D "_WINDOWS" /YX /c
  CPP_PROJ=/nologo /MLd /W3 /GX /Z7 /Od /D "WIN32" /D "_DEBUG" /D "_WINDOWS"\
!  /Fp"$(INTDIR)/cmm.pch" /YX /Fo"$(INTDIR)/" /c 
  CPP_OBJS=.\Debug/
  CPP_SBRS=
  
***************
*** 294,310 ****
  BSC32=bscmake.exe
  # ADD BASE BSC32 /nologo
  # ADD BSC32 /nologo
! BSC32_FLAGS=/nologo /o"$(OUTDIR)/lib.bsc" 
  BSC32_SBRS=
  LIB32=link.exe -lib
  # ADD BASE LIB32 /nologo
! # ADD LIB32 /nologo /out:"Debug\cmm.lib"
  LIB32_FLAGS=/nologo /out:"$(OUTDIR)/cmm.lib" 
  LIB32_OBJS= \
! 	"$(INTDIR)/memory.obj" \
  	"$(INTDIR)/cmm.obj" \
  	"$(INTDIR)/msw.obj" \
! 	"$(INTDIR)/tempheap.obj"
  
  "$(OUTDIR)\cmm.lib" : "$(OUTDIR)" $(DEF_FILE) $(LIB32_OBJS)
      $(LIB32) @<<
--- 302,318 ----
  BSC32=bscmake.exe
  # ADD BASE BSC32 /nologo
  # ADD BSC32 /nologo
! BSC32_FLAGS=/nologo /o"$(OUTDIR)/cmm.bsc" 
  BSC32_SBRS=
  LIB32=link.exe -lib
  # ADD BASE LIB32 /nologo
! # ADD LIB32 /nologo
  LIB32_FLAGS=/nologo /out:"$(OUTDIR)/cmm.lib" 
  LIB32_OBJS= \
! 	"$(INTDIR)/tempheap.obj" \
  	"$(INTDIR)/cmm.obj" \
  	"$(INTDIR)/msw.obj" \
! 	"$(INTDIR)/memory.obj"
  
  "$(OUTDIR)\cmm.lib" : "$(OUTDIR)" $(DEF_FILE) $(LIB32_OBJS)
      $(LIB32) @<<
***************
*** 326,332 ****
  OUTDIR=.\Debug
  INTDIR=.\Debug
  
! ALL : "lib - Win32 Debug" "$(OUTDIR)\test2.exe"
  
  CLEAN : 
  	-@erase ".\Debug\vc40.pdb"
--- 334,340 ----
  OUTDIR=.\Debug
  INTDIR=.\Debug
  
! ALL : "$(OUTDIR)\test2.exe"
  
  CLEAN : 
  	-@erase ".\Debug\vc40.pdb"
***************
*** 375,394 ****
  BSC32_SBRS=
  LINK32=link.exe
  # ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /debug /machine:I386
! # ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /debug /machine:I386
! LINK32_FLAGS=kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib\
!  advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib\
!  odbccp32.lib /nologo /subsystem:console /incremental:yes\
   /pdb:"$(OUTDIR)/test2.pdb" /debug /machine:I386 /out:"$(OUTDIR)/test2.exe" 
  LINK32_OBJS= \
! 	"$(INTDIR)/test2.obj" \
! 	".\Debug\cmm.lib"
  
  "$(OUTDIR)\test2.exe" : "$(OUTDIR)" $(DEF_FILE) $(LINK32_OBJS)
      $(LINK32) @<<
    $(LINK32_FLAGS) $(LINK32_OBJS)
  <<
  
  !ELSEIF  "$(CFG)" == "test3 - Win32 Debug"
  
  # PROP BASE Use_MFC 0
--- 383,475 ----
  BSC32_SBRS=
  LINK32=link.exe
  # ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /debug /machine:I386
! # ADD LINK32 Debug/cmm.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /debug /machine:I386
! LINK32_FLAGS=Debug/cmm.lib kernel32.lib user32.lib gdi32.lib winspool.lib\
!  comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib\
!  odbc32.lib odbccp32.lib /nologo /subsystem:console /incremental:yes\
   /pdb:"$(OUTDIR)/test2.pdb" /debug /machine:I386 /out:"$(OUTDIR)/test2.exe" 
  LINK32_OBJS= \
! 	"$(INTDIR)/test2.obj"
  
  "$(OUTDIR)\test2.exe" : "$(OUTDIR)" $(DEF_FILE) $(LINK32_OBJS)
      $(LINK32) @<<
    $(LINK32_FLAGS) $(LINK32_OBJS)
  <<
  
+ !ELSEIF  "$(CFG)" == "test3 - Win32 Release"
+ 
+ # PROP BASE Use_MFC 0
+ # PROP BASE Use_Debug_Libraries 0
+ # PROP BASE Output_Dir "test3\Release"
+ # PROP BASE Intermediate_Dir "test3\Release"
+ # PROP BASE Target_Dir "test3"
+ # PROP Use_MFC 0
+ # PROP Use_Debug_Libraries 0
+ # PROP Output_Dir "Release"
+ # PROP Intermediate_Dir "Release"
+ # PROP Target_Dir "test3"
+ OUTDIR=.\Release
+ INTDIR=.\Release
+ 
+ ALL : "lib - Win32 Release" "$(OUTDIR)\test3.exe"
+ 
+ CLEAN : 
+ 	-@erase ".\Release\test3.exe"
+ 	-@erase ".\Release\test3.obj"
+ 
+ "$(OUTDIR)" :
+     if not exist "$(OUTDIR)/$(NULL)" mkdir "$(OUTDIR)"
+ 
+ CPP=cl.exe
+ # ADD BASE CPP /nologo /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_CONSOLE" /YX /c
+ # ADD CPP /nologo /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_CONSOLE" /YX /c
+ CPP_PROJ=/nologo /ML /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_CONSOLE"\
+  /Fp"$(INTDIR)/test3.pch" /YX /Fo"$(INTDIR)/" /c 
+ CPP_OBJS=.\Release/
+ CPP_SBRS=
+ 
+ .c{$(CPP_OBJS)}.obj:
+    $(CPP) $(CPP_PROJ) $<  
+ 
+ .cpp{$(CPP_OBJS)}.obj:
+    $(CPP) $(CPP_PROJ) $<  
+ 
+ .cxx{$(CPP_OBJS)}.obj:
+    $(CPP) $(CPP_PROJ) $<  
+ 
+ .c{$(CPP_SBRS)}.sbr:
+    $(CPP) $(CPP_PROJ) $<  
+ 
+ .cpp{$(CPP_SBRS)}.sbr:
+    $(CPP) $(CPP_PROJ) $<  
+ 
+ .cxx{$(CPP_SBRS)}.sbr:
+    $(CPP) $(CPP_PROJ) $<  
+ 
+ RSC=rc.exe
+ # ADD BASE RSC /l 0x410 /d "NDEBUG"
+ # ADD RSC /l 0x409 /d "NDEBUG"
+ BSC32=bscmake.exe
+ # ADD BASE BSC32 /nologo
+ # ADD BSC32 /nologo
+ BSC32_FLAGS=/nologo /o"$(OUTDIR)/test3.bsc" 
+ BSC32_SBRS=
+ LINK32=link.exe
+ # ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /machine:I386
+ # ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /machine:I386
+ LINK32_FLAGS=kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib\
+  advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib\
+  odbccp32.lib /nologo /subsystem:console /incremental:no\
+  /pdb:"$(OUTDIR)/test3.pdb" /machine:I386 /out:"$(OUTDIR)/test3.exe" 
+ LINK32_OBJS= \
+ 	"$(INTDIR)/test3.obj" \
+ 	".\Release\cmm.lib"
+ 
+ "$(OUTDIR)\test3.exe" : "$(OUTDIR)" $(DEF_FILE) $(LINK32_OBJS)
+     $(LINK32) @<<
+   $(LINK32_FLAGS) $(LINK32_OBJS)
+ <<
+ 
  !ELSEIF  "$(CFG)" == "test3 - Win32 Debug"
  
  # PROP BASE Use_MFC 0
***************
*** 404,410 ****
  OUTDIR=.\Debug
  INTDIR=.\Debug
  
! ALL : "lib - Win32 Debug" "$(OUTDIR)\test3.exe"
  
  CLEAN : 
  	-@erase ".\Debug\vc40.pdb"
--- 485,491 ----
  OUTDIR=.\Debug
  INTDIR=.\Debug
  
! ALL : "$(OUTDIR)\test3.exe"
  
  CLEAN : 
  	-@erase ".\Debug\vc40.pdb"
***************
*** 453,472 ****
  BSC32_SBRS=
  LINK32=link.exe
  # ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /debug /machine:I386
! # ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /debug /machine:I386
! LINK32_FLAGS=kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib\
!  advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib\
!  odbccp32.lib /nologo /subsystem:console /incremental:yes\
   /pdb:"$(OUTDIR)/test3.pdb" /debug /machine:I386 /out:"$(OUTDIR)/test3.exe" 
  LINK32_OBJS= \
! 	"$(INTDIR)/test3.obj" \
! 	".\Debug\cmm.lib"
  
  "$(OUTDIR)\test3.exe" : "$(OUTDIR)" $(DEF_FILE) $(LINK32_OBJS)
      $(LINK32) @<<
    $(LINK32_FLAGS) $(LINK32_OBJS)
  <<
  
  !ELSEIF  "$(CFG)" == "test4 - Win32 Debug"
  
  # PROP BASE Use_MFC 0
--- 534,626 ----
  BSC32_SBRS=
  LINK32=link.exe
  # ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /debug /machine:I386
! # ADD LINK32 Debug/cmm.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /debug /machine:I386
! LINK32_FLAGS=Debug/cmm.lib kernel32.lib user32.lib gdi32.lib winspool.lib\
!  comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib\
!  odbc32.lib odbccp32.lib /nologo /subsystem:console /incremental:yes\
   /pdb:"$(OUTDIR)/test3.pdb" /debug /machine:I386 /out:"$(OUTDIR)/test3.exe" 
  LINK32_OBJS= \
! 	"$(INTDIR)/test3.obj"
  
  "$(OUTDIR)\test3.exe" : "$(OUTDIR)" $(DEF_FILE) $(LINK32_OBJS)
      $(LINK32) @<<
    $(LINK32_FLAGS) $(LINK32_OBJS)
  <<
  
+ !ELSEIF  "$(CFG)" == "test4 - Win32 Release"
+ 
+ # PROP BASE Use_MFC 0
+ # PROP BASE Use_Debug_Libraries 0
+ # PROP BASE Output_Dir "test4\Release"
+ # PROP BASE Intermediate_Dir "test4\Release"
+ # PROP BASE Target_Dir "test4"
+ # PROP Use_MFC 0
+ # PROP Use_Debug_Libraries 0
+ # PROP Output_Dir "Release"
+ # PROP Intermediate_Dir "Release"
+ # PROP Target_Dir "test4"
+ OUTDIR=.\Release
+ INTDIR=.\Release
+ 
+ ALL : "lib - Win32 Release" "$(OUTDIR)\test4.exe"
+ 
+ CLEAN : 
+ 	-@erase ".\Release\test4.exe"
+ 	-@erase ".\Release\test4.obj"
+ 
+ "$(OUTDIR)" :
+     if not exist "$(OUTDIR)/$(NULL)" mkdir "$(OUTDIR)"
+ 
+ CPP=cl.exe
+ # ADD BASE CPP /nologo /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_CONSOLE" /YX /c
+ # ADD CPP /nologo /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_CONSOLE" /YX /c
+ CPP_PROJ=/nologo /ML /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_CONSOLE"\
+  /Fp"$(INTDIR)/test4.pch" /YX /Fo"$(INTDIR)/" /c 
+ CPP_OBJS=.\Release/
+ CPP_SBRS=
+ 
+ .c{$(CPP_OBJS)}.obj:
+    $(CPP) $(CPP_PROJ) $<  
+ 
+ .cpp{$(CPP_OBJS)}.obj:
+    $(CPP) $(CPP_PROJ) $<  
+ 
+ .cxx{$(CPP_OBJS)}.obj:
+    $(CPP) $(CPP_PROJ) $<  
+ 
+ .c{$(CPP_SBRS)}.sbr:
+    $(CPP) $(CPP_PROJ) $<  
+ 
+ .cpp{$(CPP_SBRS)}.sbr:
+    $(CPP) $(CPP_PROJ) $<  
+ 
+ .cxx{$(CPP_SBRS)}.sbr:
+    $(CPP) $(CPP_PROJ) $<  
+ 
+ RSC=rc.exe
+ # ADD BASE RSC /l 0x410 /d "NDEBUG"
+ # ADD RSC /l 0x409 /d "NDEBUG"
+ BSC32=bscmake.exe
+ # ADD BASE BSC32 /nologo
+ # ADD BSC32 /nologo
+ BSC32_FLAGS=/nologo /o"$(OUTDIR)/test4.bsc" 
+ BSC32_SBRS=
+ LINK32=link.exe
+ # ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /machine:I386
+ # ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /machine:I386
+ LINK32_FLAGS=kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib\
+  advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib\
+  odbccp32.lib /nologo /subsystem:console /incremental:no\
+  /pdb:"$(OUTDIR)/test4.pdb" /machine:I386 /out:"$(OUTDIR)/test4.exe" 
+ LINK32_OBJS= \
+ 	"$(INTDIR)/test4.obj" \
+ 	".\Release\cmm.lib"
+ 
+ "$(OUTDIR)\test4.exe" : "$(OUTDIR)" $(DEF_FILE) $(LINK32_OBJS)
+     $(LINK32) @<<
+   $(LINK32_FLAGS) $(LINK32_OBJS)
+ <<
+ 
  !ELSEIF  "$(CFG)" == "test4 - Win32 Debug"
  
  # PROP BASE Use_MFC 0
***************
*** 482,488 ****
  OUTDIR=.\Debug
  INTDIR=.\Debug
  
! ALL : "lib - Win32 Debug" "$(OUTDIR)\test4.exe"
  
  CLEAN : 
  	-@erase ".\Debug\vc40.pdb"
--- 636,642 ----
  OUTDIR=.\Debug
  INTDIR=.\Debug
  
! ALL : "$(OUTDIR)\test4.exe"
  
  CLEAN : 
  	-@erase ".\Debug\vc40.pdb"
***************
*** 531,550 ****
  BSC32_SBRS=
  LINK32=link.exe
  # ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /debug /machine:I386
! # ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /debug /machine:I386
! LINK32_FLAGS=kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib\
!  advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib\
!  odbccp32.lib /nologo /subsystem:console /incremental:yes\
   /pdb:"$(OUTDIR)/test4.pdb" /debug /machine:I386 /out:"$(OUTDIR)/test4.exe" 
  LINK32_OBJS= \
! 	"$(INTDIR)/test4.obj" \
! 	".\Debug\cmm.lib"
  
  "$(OUTDIR)\test4.exe" : "$(OUTDIR)" $(DEF_FILE) $(LINK32_OBJS)
      $(LINK32) @<<
    $(LINK32_FLAGS) $(LINK32_OBJS)
  <<
  
  !ELSEIF  "$(CFG)" == "test5 - Win32 Debug"
  
  # PROP BASE Use_MFC 0
--- 685,777 ----
  BSC32_SBRS=
  LINK32=link.exe
  # ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /debug /machine:I386
! # ADD LINK32 Debug/cmm.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /debug /machine:I386
! LINK32_FLAGS=Debug/cmm.lib kernel32.lib user32.lib gdi32.lib winspool.lib\
!  comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib\
!  odbc32.lib odbccp32.lib /nologo /subsystem:console /incremental:yes\
   /pdb:"$(OUTDIR)/test4.pdb" /debug /machine:I386 /out:"$(OUTDIR)/test4.exe" 
  LINK32_OBJS= \
! 	"$(INTDIR)/test4.obj"
  
  "$(OUTDIR)\test4.exe" : "$(OUTDIR)" $(DEF_FILE) $(LINK32_OBJS)
      $(LINK32) @<<
    $(LINK32_FLAGS) $(LINK32_OBJS)
  <<
  
+ !ELSEIF  "$(CFG)" == "test5 - Win32 Release"
+ 
+ # PROP BASE Use_MFC 0
+ # PROP BASE Use_Debug_Libraries 0
+ # PROP BASE Output_Dir "test5\Release"
+ # PROP BASE Intermediate_Dir "test5\Release"
+ # PROP BASE Target_Dir "test5"
+ # PROP Use_MFC 0
+ # PROP Use_Debug_Libraries 0
+ # PROP Output_Dir "Release"
+ # PROP Intermediate_Dir "Release"
+ # PROP Target_Dir "test5"
+ OUTDIR=.\Release
+ INTDIR=.\Release
+ 
+ ALL : "lib - Win32 Release" "$(OUTDIR)\test5.exe"
+ 
+ CLEAN : 
+ 	-@erase ".\Release\test5.exe"
+ 	-@erase ".\Release\test5.obj"
+ 
+ "$(OUTDIR)" :
+     if not exist "$(OUTDIR)/$(NULL)" mkdir "$(OUTDIR)"
+ 
+ CPP=cl.exe
+ # ADD BASE CPP /nologo /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_CONSOLE" /YX /c
+ # ADD CPP /nologo /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_CONSOLE" /YX /c
+ CPP_PROJ=/nologo /ML /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_CONSOLE"\
+  /Fp"$(INTDIR)/test5.pch" /YX /Fo"$(INTDIR)/" /c 
+ CPP_OBJS=.\Release/
+ CPP_SBRS=
+ 
+ .c{$(CPP_OBJS)}.obj:
+    $(CPP) $(CPP_PROJ) $<  
+ 
+ .cpp{$(CPP_OBJS)}.obj:
+    $(CPP) $(CPP_PROJ) $<  
+ 
+ .cxx{$(CPP_OBJS)}.obj:
+    $(CPP) $(CPP_PROJ) $<  
+ 
+ .c{$(CPP_SBRS)}.sbr:
+    $(CPP) $(CPP_PROJ) $<  
+ 
+ .cpp{$(CPP_SBRS)}.sbr:
+    $(CPP) $(CPP_PROJ) $<  
+ 
+ .cxx{$(CPP_SBRS)}.sbr:
+    $(CPP) $(CPP_PROJ) $<  
+ 
+ RSC=rc.exe
+ # ADD BASE RSC /l 0x410 /d "NDEBUG"
+ # ADD RSC /l 0x409 /d "NDEBUG"
+ BSC32=bscmake.exe
+ # ADD BASE BSC32 /nologo
+ # ADD BSC32 /nologo
+ BSC32_FLAGS=/nologo /o"$(OUTDIR)/test5.bsc" 
+ BSC32_SBRS=
+ LINK32=link.exe
+ # ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /machine:I386
+ # ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /machine:I386
+ LINK32_FLAGS=kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib\
+  advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib\
+  odbccp32.lib /nologo /subsystem:console /incremental:no\
+  /pdb:"$(OUTDIR)/test5.pdb" /machine:I386 /out:"$(OUTDIR)/test5.exe" 
+ LINK32_OBJS= \
+ 	"$(INTDIR)/test5.obj" \
+ 	".\Release\cmm.lib"
+ 
+ "$(OUTDIR)\test5.exe" : "$(OUTDIR)" $(DEF_FILE) $(LINK32_OBJS)
+     $(LINK32) @<<
+   $(LINK32_FLAGS) $(LINK32_OBJS)
+ <<
+ 
  !ELSEIF  "$(CFG)" == "test5 - Win32 Debug"
  
  # PROP BASE Use_MFC 0
***************
*** 560,566 ****
  OUTDIR=.\Debug
  INTDIR=.\Debug
  
! ALL : "lib - Win32 Debug" "$(OUTDIR)\test5.exe"
  
  CLEAN : 
  	-@erase ".\Debug\vc40.pdb"
--- 787,793 ----
  OUTDIR=.\Debug
  INTDIR=.\Debug
  
! ALL : "$(OUTDIR)\test5.exe"
  
  CLEAN : 
  	-@erase ".\Debug\vc40.pdb"
***************
*** 609,628 ****
  BSC32_SBRS=
  LINK32=link.exe
  # ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /debug /machine:I386
! # ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /debug /machine:I386
! LINK32_FLAGS=kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib\
!  advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib\
!  odbccp32.lib /nologo /subsystem:console /incremental:yes\
   /pdb:"$(OUTDIR)/test5.pdb" /debug /machine:I386 /out:"$(OUTDIR)/test5.exe" 
  LINK32_OBJS= \
! 	"$(INTDIR)/test5.obj" \
! 	".\Debug\cmm.lib"
  
  "$(OUTDIR)\test5.exe" : "$(OUTDIR)" $(DEF_FILE) $(LINK32_OBJS)
      $(LINK32) @<<
    $(LINK32_FLAGS) $(LINK32_OBJS)
  <<
  
  !ELSEIF  "$(CFG)" == "test6 - Win32 Debug"
  
  # PROP BASE Use_MFC 0
--- 836,928 ----
  BSC32_SBRS=
  LINK32=link.exe
  # ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /debug /machine:I386
! # ADD LINK32 Debug/cmm.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /debug /machine:I386
! LINK32_FLAGS=Debug/cmm.lib kernel32.lib user32.lib gdi32.lib winspool.lib\
!  comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib\
!  odbc32.lib odbccp32.lib /nologo /subsystem:console /incremental:yes\
   /pdb:"$(OUTDIR)/test5.pdb" /debug /machine:I386 /out:"$(OUTDIR)/test5.exe" 
  LINK32_OBJS= \
! 	"$(INTDIR)/test5.obj"
  
  "$(OUTDIR)\test5.exe" : "$(OUTDIR)" $(DEF_FILE) $(LINK32_OBJS)
      $(LINK32) @<<
    $(LINK32_FLAGS) $(LINK32_OBJS)
  <<
  
+ !ELSEIF  "$(CFG)" == "test6 - Win32 Release"
+ 
+ # PROP BASE Use_MFC 0
+ # PROP BASE Use_Debug_Libraries 0
+ # PROP BASE Output_Dir "test6\Release"
+ # PROP BASE Intermediate_Dir "test6\Release"
+ # PROP BASE Target_Dir "test6"
+ # PROP Use_MFC 0
+ # PROP Use_Debug_Libraries 0
+ # PROP Output_Dir "Release"
+ # PROP Intermediate_Dir "Release"
+ # PROP Target_Dir "test6"
+ OUTDIR=.\Release
+ INTDIR=.\Release
+ 
+ ALL : "lib - Win32 Release" "$(OUTDIR)\test6.exe"
+ 
+ CLEAN : 
+ 	-@erase ".\Release\test6.exe"
+ 	-@erase ".\Release\test6.obj"
+ 
+ "$(OUTDIR)" :
+     if not exist "$(OUTDIR)/$(NULL)" mkdir "$(OUTDIR)"
+ 
+ CPP=cl.exe
+ # ADD BASE CPP /nologo /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_CONSOLE" /YX /c
+ # ADD CPP /nologo /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_CONSOLE" /YX /c
+ CPP_PROJ=/nologo /ML /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_CONSOLE"\
+  /Fp"$(INTDIR)/test6.pch" /YX /Fo"$(INTDIR)/" /c 
+ CPP_OBJS=.\Release/
+ CPP_SBRS=
+ 
+ .c{$(CPP_OBJS)}.obj:
+    $(CPP) $(CPP_PROJ) $<  
+ 
+ .cpp{$(CPP_OBJS)}.obj:
+    $(CPP) $(CPP_PROJ) $<  
+ 
+ .cxx{$(CPP_OBJS)}.obj:
+    $(CPP) $(CPP_PROJ) $<  
+ 
+ .c{$(CPP_SBRS)}.sbr:
+    $(CPP) $(CPP_PROJ) $<  
+ 
+ .cpp{$(CPP_SBRS)}.sbr:
+    $(CPP) $(CPP_PROJ) $<  
+ 
+ .cxx{$(CPP_SBRS)}.sbr:
+    $(CPP) $(CPP_PROJ) $<  
+ 
+ RSC=rc.exe
+ # ADD BASE RSC /l 0x410 /d "NDEBUG"
+ # ADD RSC /l 0x409 /d "NDEBUG"
+ BSC32=bscmake.exe
+ # ADD BASE BSC32 /nologo
+ # ADD BSC32 /nologo
+ BSC32_FLAGS=/nologo /o"$(OUTDIR)/test6.bsc" 
+ BSC32_SBRS=
+ LINK32=link.exe
+ # ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /machine:I386
+ # ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /machine:I386
+ LINK32_FLAGS=kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib\
+  advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib\
+  odbccp32.lib /nologo /subsystem:console /incremental:no\
+  /pdb:"$(OUTDIR)/test6.pdb" /machine:I386 /out:"$(OUTDIR)/test6.exe" 
+ LINK32_OBJS= \
+ 	"$(INTDIR)/test6.obj" \
+ 	".\Release\cmm.lib"
+ 
+ "$(OUTDIR)\test6.exe" : "$(OUTDIR)" $(DEF_FILE) $(LINK32_OBJS)
+     $(LINK32) @<<
+   $(LINK32_FLAGS) $(LINK32_OBJS)
+ <<
+ 
  !ELSEIF  "$(CFG)" == "test6 - Win32 Debug"
  
  # PROP BASE Use_MFC 0
***************
*** 638,644 ****
  OUTDIR=.\Debug
  INTDIR=.\Debug
  
! ALL : "lib - Win32 Debug" "$(OUTDIR)\test6.exe"
  
  CLEAN : 
  	-@erase ".\Debug\vc40.pdb"
--- 938,944 ----
  OUTDIR=.\Debug
  INTDIR=.\Debug
  
! ALL : "$(OUTDIR)\test6.exe"
  
  CLEAN : 
  	-@erase ".\Debug\vc40.pdb"
***************
*** 687,700 ****
  BSC32_SBRS=
  LINK32=link.exe
  # ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /debug /machine:I386
! # ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /debug /machine:I386
! LINK32_FLAGS=kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib\
!  advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib\
!  odbccp32.lib /nologo /subsystem:console /incremental:yes\
   /pdb:"$(OUTDIR)/test6.pdb" /debug /machine:I386 /out:"$(OUTDIR)/test6.exe" 
  LINK32_OBJS= \
! 	"$(INTDIR)/test6.obj" \
! 	".\Debug\cmm.lib"
  
  "$(OUTDIR)\test6.exe" : "$(OUTDIR)" $(DEF_FILE) $(LINK32_OBJS)
      $(LINK32) @<<
--- 987,999 ----
  BSC32_SBRS=
  LINK32=link.exe
  # ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /debug /machine:I386
! # ADD LINK32 Debug/cmm.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /debug /machine:I386
! LINK32_FLAGS=Debug/cmm.lib kernel32.lib user32.lib gdi32.lib winspool.lib\
!  comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib\
!  odbc32.lib odbccp32.lib /nologo /subsystem:console /incremental:yes\
   /pdb:"$(OUTDIR)/test6.pdb" /debug /machine:I386 /out:"$(OUTDIR)/test6.exe" 
  LINK32_OBJS= \
! 	"$(INTDIR)/test6.obj"
  
  "$(OUTDIR)\test6.exe" : "$(OUTDIR)" $(DEF_FILE) $(LINK32_OBJS)
      $(LINK32) @<<
***************
*** 740,745 ****
--- 1039,1047 ----
  
  !IF  "$(CFG)" == "cmm - Win32 Release"
  
+ "test2 - Win32 Release" : 
+    $(MAKE) /$(MAKEFLAGS) /F .\cmm.mak CFG="test2 - Win32 Release" 
+ 
  !ELSEIF  "$(CFG)" == "cmm - Win32 Debug"
  
  "test2 - Win32 Debug" : 
***************
*** 755,760 ****
--- 1057,1065 ----
  
  !IF  "$(CFG)" == "cmm - Win32 Release"
  
+ "test3 - Win32 Release" : 
+    $(MAKE) /$(MAKEFLAGS) /F .\cmm.mak CFG="test3 - Win32 Release" 
+ 
  !ELSEIF  "$(CFG)" == "cmm - Win32 Debug"
  
  "test3 - Win32 Debug" : 
***************
*** 770,775 ****
--- 1075,1083 ----
  
  !IF  "$(CFG)" == "cmm - Win32 Release"
  
+ "test4 - Win32 Release" : 
+    $(MAKE) /$(MAKEFLAGS) /F .\cmm.mak CFG="test4 - Win32 Release" 
+ 
  !ELSEIF  "$(CFG)" == "cmm - Win32 Debug"
  
  "test4 - Win32 Debug" : 
***************
*** 785,790 ****
--- 1093,1101 ----
  
  !IF  "$(CFG)" == "cmm - Win32 Release"
  
+ "test5 - Win32 Release" : 
+    $(MAKE) /$(MAKEFLAGS) /F .\cmm.mak CFG="test5 - Win32 Release" 
+ 
  !ELSEIF  "$(CFG)" == "cmm - Win32 Debug"
  
  "test5 - Win32 Debug" : 
***************
*** 800,805 ****
--- 1111,1119 ----
  
  !IF  "$(CFG)" == "cmm - Win32 Release"
  
+ "test6 - Win32 Release" : 
+    $(MAKE) /$(MAKEFLAGS) /F .\cmm.mak CFG="test6 - Win32 Release" 
+ 
  !ELSEIF  "$(CFG)" == "cmm - Win32 Debug"
  
  "test6 - Win32 Debug" : 
***************
*** 848,869 ****
  ################################################################################
  # Begin Source File
  
! SOURCE=.\machine.h
! 
! !IF  "$(CFG)" == "lib - Win32 Release"
  
! !ELSEIF  "$(CFG)" == "lib - Win32 Debug"
  
- !ENDIF 
  
  # End Source File
  ################################################################################
  # Begin Source File
  
  SOURCE=.\msw.cpp
  DEP_CPP_MSW_C=\
  	".\cmm.h"\
! 	{$(INCLUDE)}"\sys\Types.h"\
  	".\machine.h"\
  	".\msw.h"\
  	
--- 1162,1186 ----
  ################################################################################
  # Begin Source File
  
! SOURCE=.\memory.cpp
! DEP_CPP_MEMOR=\
! 	".\machine.h"\
! 	
  
! "$(INTDIR)\memory.obj" : $(SOURCE) $(DEP_CPP_MEMOR) "$(INTDIR)"
  
  
  # End Source File
  ################################################################################
  # Begin Source File
  
  SOURCE=.\msw.cpp
+ 
+ !IF  "$(CFG)" == "lib - Win32 Release"
+ 
  DEP_CPP_MSW_C=\
  	".\cmm.h"\
! 	{$(INCLUDE)}"\sys\types.h"\
  	".\machine.h"\
  	".\msw.h"\
  	
***************
*** 871,885 ****
  "$(INTDIR)\msw.obj" : $(SOURCE) $(DEP_CPP_MSW_C) "$(INTDIR)"
  
  
! # End Source File
! ################################################################################
! # Begin Source File
  
! SOURCE=.\msw.h
  
! !IF  "$(CFG)" == "lib - Win32 Release"
  
- !ELSEIF  "$(CFG)" == "lib - Win32 Debug"
  
  !ENDIF 
  
--- 1188,1204 ----
  "$(INTDIR)\msw.obj" : $(SOURCE) $(DEP_CPP_MSW_C) "$(INTDIR)"
  
  
! !ELSEIF  "$(CFG)" == "lib - Win32 Debug"
  
! DEP_CPP_MSW_C=\
! 	".\cmm.h"\
! 	{$(INCLUDE)}"\sys\Types.h"\
! 	".\machine.h"\
! 	".\msw.h"\
! 	
  
! "$(INTDIR)\msw.obj" : $(SOURCE) $(DEP_CPP_MSW_C) "$(INTDIR)"
  
  
  !ENDIF 
  
***************
*** 887,933 ****
  ################################################################################
  # Begin Source File
  
! SOURCE=.\tempheap.cpp
! DEP_CPP_TEMPH=\
! 	".\tempheap.h"\
! 	".\cmm.h"\
! 	".\machine.h"\
! 	".\msw.h"\
! 	
  
! "$(INTDIR)\tempheap.obj" : $(SOURCE) $(DEP_CPP_TEMPH) "$(INTDIR)"
  
  
  # End Source File
  ################################################################################
  # Begin Source File
  
! SOURCE=.\cmm.cpp
  
  !IF  "$(CFG)" == "lib - Win32 Release"
  
! DEP_CPP_CMM_C=\
  	".\cmm.h"\
  	".\machine.h"\
  	".\msw.h"\
  	
- NODEP_CPP_CMM_C=\
- 	".\heap"\
- 	".\if"\
- 	
  
! "$(INTDIR)\cmm.obj" : $(SOURCE) $(DEP_CPP_CMM_C) "$(INTDIR)"
  
  
  !ELSEIF  "$(CFG)" == "lib - Win32 Debug"
  
! DEP_CPP_CMM_C=\
  	".\cmm.h"\
  	".\machine.h"\
  	".\msw.h"\
  	
  
! "$(INTDIR)\cmm.obj" : $(SOURCE) $(DEP_CPP_CMM_C) "$(INTDIR)"
  
  
  !ENDIF 
--- 1206,1247 ----
  ################################################################################
  # Begin Source File
  
! SOURCE=.\msw.h
  
! !IF  "$(CFG)" == "cmm - Win32 Release"
  
+ !ELSEIF  "$(CFG)" == "cmm - Win32 Debug"
+ 
+ !ENDIF 
  
  # End Source File
  ################################################################################
  # Begin Source File
  
! SOURCE=.\tempheap.cpp
  
  !IF  "$(CFG)" == "lib - Win32 Release"
  
! DEP_CPP_TEMPH=\
! 	".\tempheap.h"\
  	".\cmm.h"\
  	".\machine.h"\
  	".\msw.h"\
  	
  
! "$(INTDIR)\tempheap.obj" : $(SOURCE) $(DEP_CPP_TEMPH) "$(INTDIR)"
  
  
  !ELSEIF  "$(CFG)" == "lib - Win32 Debug"
  
! DEP_CPP_TEMPH=\
! 	".\tempheap.h"\
  	".\cmm.h"\
  	".\machine.h"\
  	".\msw.h"\
  	
  
! "$(INTDIR)\tempheap.obj" : $(SOURCE) $(DEP_CPP_TEMPH) "$(INTDIR)"
  
  
  !ENDIF 
***************
*** 936,978 ****
  ################################################################################
  # Begin Source File
  
! SOURCE=.\memory.cpp
! 
! !IF  "$(CFG)" == "lib - Win32 Release"
! 
! DEP_CPP_MEMOR=\
! 	".\machine.h"\
! 	
! NODEP_CPP_MEMOR=\
! 	".\CmmLeastDescribedAddress"\
! 	
! 
! "$(INTDIR)\memory.obj" : $(SOURCE) $(DEP_CPP_MEMOR) "$(INTDIR)"
! 
! 
! !ELSEIF  "$(CFG)" == "lib - Win32 Debug"
! 
! DEP_CPP_MEMOR=\
! 	".\machine.h"\
! 	
! 
! "$(INTDIR)\memory.obj" : $(SOURCE) $(DEP_CPP_MEMOR) "$(INTDIR)"
  
  
! !ENDIF 
  
  # End Source File
  # End Target
  ################################################################################
  # Begin Target
  
  # Name "test2 - Win32 Debug"
  ################################################################################
  # Begin Project Dependency
  
  # Project_Dep_Name "lib"
  
! !IF  "$(CFG)" == "test2 - Win32 Debug"
  
  "lib - Win32 Debug" : 
     $(MAKE) /$(MAKEFLAGS) /F .\cmm.mak CFG="lib - Win32 Debug" 
--- 1250,1286 ----
  ################################################################################
  # Begin Source File
  
! SOURCE=.\tempheap.h
  
+ !IF  "$(CFG)" == "cmm - Win32 Release"
  
! !ELSEIF  "$(CFG)" == "cmm - Win32 Debug"
  
  # End Source File
  # End Target
  ################################################################################
  # Begin Target
  
+ # Name "test2 - Win32 Release"
  # Name "test2 - Win32 Debug"
+ 
+ !IF  "$(CFG)" == "test2 - Win32 Release"
+ 
+ !ELSEIF  "$(CFG)" == "test2 - Win32 Debug"
+ 
+ !ENDIF 
+ 
  ################################################################################
  # Begin Project Dependency
  
  # Project_Dep_Name "lib"
  
! !IF  "$(CFG)" == "test2 - Win32 Release"
! 
! "lib - Win32 Release" : 
!    $(MAKE) /$(MAKEFLAGS) /F .\cmm.mak CFG="lib - Win32 Release" 
! 
! !ELSEIF  "$(CFG)" == "test2 - Win32 Debug"
  
  "lib - Win32 Debug" : 
     $(MAKE) /$(MAKEFLAGS) /F .\cmm.mak CFG="lib - Win32 Debug" 
***************
*** 993,1010 ****
  "$(INTDIR)\test2.obj" : $(SOURCE) $(DEP_CPP_TEST2) "$(INTDIR)"
  
  
  # End Source File
  # End Target
  ################################################################################
  # Begin Target
  
  # Name "test3 - Win32 Debug"
  ################################################################################
  # Begin Project Dependency
  
  # Project_Dep_Name "lib"
  
! !IF  "$(CFG)" == "test3 - Win32 Debug"
  
  "lib - Win32 Debug" : 
     $(MAKE) /$(MAKEFLAGS) /F .\cmm.mak CFG="lib - Win32 Debug" 
--- 1301,1333 ----
  "$(INTDIR)\test2.obj" : $(SOURCE) $(DEP_CPP_TEST2) "$(INTDIR)"
  
  
+ !ENDIF 
+ 
  # End Source File
  # End Target
  ################################################################################
  # Begin Target
  
+ # Name "test3 - Win32 Release"
  # Name "test3 - Win32 Debug"
+ 
+ !IF  "$(CFG)" == "test3 - Win32 Release"
+ 
+ !ELSEIF  "$(CFG)" == "test3 - Win32 Debug"
+ 
+ !ENDIF 
+ 
  ################################################################################
  # Begin Project Dependency
  
  # Project_Dep_Name "lib"
  
! !IF  "$(CFG)" == "test3 - Win32 Release"
! 
! "lib - Win32 Release" : 
!    $(MAKE) /$(MAKEFLAGS) /F .\cmm.mak CFG="lib - Win32 Release" 
! 
! !ELSEIF  "$(CFG)" == "test3 - Win32 Debug"
  
  "lib - Win32 Debug" : 
     $(MAKE) /$(MAKEFLAGS) /F .\cmm.mak CFG="lib - Win32 Debug" 
***************
*** 1025,1042 ****
  "$(INTDIR)\test3.obj" : $(SOURCE) $(DEP_CPP_TEST3) "$(INTDIR)"
  
  
  # End Source File
  # End Target
  ################################################################################
  # Begin Target
  
  # Name "test4 - Win32 Debug"
  ################################################################################
  # Begin Project Dependency
  
  # Project_Dep_Name "lib"
  
! !IF  "$(CFG)" == "test4 - Win32 Debug"
  
  "lib - Win32 Debug" : 
     $(MAKE) /$(MAKEFLAGS) /F .\cmm.mak CFG="lib - Win32 Debug" 
--- 1348,1380 ----
  "$(INTDIR)\test3.obj" : $(SOURCE) $(DEP_CPP_TEST3) "$(INTDIR)"
  
  
+ !ENDIF 
+ 
  # End Source File
  # End Target
  ################################################################################
  # Begin Target
  
+ # Name "test4 - Win32 Release"
  # Name "test4 - Win32 Debug"
+ 
+ !IF  "$(CFG)" == "test4 - Win32 Release"
+ 
+ !ELSEIF  "$(CFG)" == "test4 - Win32 Debug"
+ 
+ !ENDIF 
+ 
  ################################################################################
  # Begin Project Dependency
  
  # Project_Dep_Name "lib"
  
! !IF  "$(CFG)" == "test4 - Win32 Release"
! 
! "lib - Win32 Release" : 
!    $(MAKE) /$(MAKEFLAGS) /F .\cmm.mak CFG="lib - Win32 Release" 
! 
! !ELSEIF  "$(CFG)" == "test4 - Win32 Debug"
  
  "lib - Win32 Debug" : 
     $(MAKE) /$(MAKEFLAGS) /F .\cmm.mak CFG="lib - Win32 Debug" 
***************
*** 1051,1056 ****
--- 1389,1395 ----
  DEP_CPP_TEST4=\
  	".\cmm.h"\
  	".\machine.h"\
+ 	".\msw.h"\
  	
  
  "$(INTDIR)\test4.obj" : $(SOURCE) $(DEP_CPP_TEST4) "$(INTDIR)"
***************
*** 1061,1073 ****
  ################################################################################
  # Begin Target
  
  # Name "test5 - Win32 Debug"
  ################################################################################
  # Begin Project Dependency
  
  # Project_Dep_Name "lib"
  
! !IF  "$(CFG)" == "test5 - Win32 Debug"
  
  "lib - Win32 Debug" : 
     $(MAKE) /$(MAKEFLAGS) /F .\cmm.mak CFG="lib - Win32 Debug" 
--- 1400,1425 ----
  ################################################################################
  # Begin Target
  
+ # Name "test5 - Win32 Release"
  # Name "test5 - Win32 Debug"
+ 
+ !IF  "$(CFG)" == "test5 - Win32 Release"
+ 
+ !ELSEIF  "$(CFG)" == "test5 - Win32 Debug"
+ 
+ !ENDIF 
+ 
  ################################################################################
  # Begin Project Dependency
  
  # Project_Dep_Name "lib"
  
! !IF  "$(CFG)" == "test5 - Win32 Release"
! 
! "lib - Win32 Release" : 
!    $(MAKE) /$(MAKEFLAGS) /F .\cmm.mak CFG="lib - Win32 Release" 
! 
! !ELSEIF  "$(CFG)" == "test5 - Win32 Debug"
  
  "lib - Win32 Debug" : 
     $(MAKE) /$(MAKEFLAGS) /F .\cmm.mak CFG="lib - Win32 Debug" 
***************
*** 1089,1106 ****
  "$(INTDIR)\test5.obj" : $(SOURCE) $(DEP_CPP_TEST5) "$(INTDIR)"
  
  
  # End Source File
  # End Target
  ################################################################################
  # Begin Target
  
  # Name "test6 - Win32 Debug"
  ################################################################################
  # Begin Project Dependency
  
  # Project_Dep_Name "lib"
  
! !IF  "$(CFG)" == "test6 - Win32 Debug"
  
  "lib - Win32 Debug" : 
     $(MAKE) /$(MAKEFLAGS) /F .\cmm.mak CFG="lib - Win32 Debug" 
--- 1441,1473 ----
  "$(INTDIR)\test5.obj" : $(SOURCE) $(DEP_CPP_TEST5) "$(INTDIR)"
  
  
+ !ENDIF 
+ 
  # End Source File
  # End Target
  ################################################################################
  # Begin Target
  
+ # Name "test6 - Win32 Release"
  # Name "test6 - Win32 Debug"
+ 
+ !IF  "$(CFG)" == "test6 - Win32 Release"
+ 
+ !ELSEIF  "$(CFG)" == "test6 - Win32 Debug"
+ 
+ !ENDIF 
+ 
  ################################################################################
  # Begin Project Dependency
  
  # Project_Dep_Name "lib"
  
! !IF  "$(CFG)" == "test6 - Win32 Release"
! 
! "lib - Win32 Release" : 
!    $(MAKE) /$(MAKEFLAGS) /F .\cmm.mak CFG="lib - Win32 Release" 
! 
! !ELSEIF  "$(CFG)" == "test6 - Win32 Debug"
  
  "lib - Win32 Debug" : 
     $(MAKE) /$(MAKEFLAGS) /F .\cmm.mak CFG="lib - Win32 Debug" 
***************
*** 1121,1126 ****
--- 1488,1495 ----
  
  "$(INTDIR)\test6.obj" : $(SOURCE) $(DEP_CPP_TEST6) "$(INTDIR)"
  
+ 
+ !ENDIF 
  
  # End Source File
  # End Target
Only in /project/posso/cmm/curr/cmm: cmm.mak.orig
Only in /project/posso/cmm/curr/cmm: cmm.mak.rej
Only in /project/posso/cmm/curr/cmm: cmm.mak.rej.orig
Common subdirectories: /home/omega/attardi/posso/cmm/doc and /project/posso/cmm/curr/cmm/doc
diff -c /home/omega/attardi/posso/cmm/machine.h /project/posso/cmm/curr/cmm/machine.h
*** /home/omega/attardi/posso/cmm/machine.h	Tue Feb 25 23:07:34 1997
--- /project/posso/cmm/curr/cmm/machine.h	Tue Feb 25 22:54:12 1997
***************
*** 47,53 ****
  typedef unsigned long	Word;
  typedef char *		Ptr;
  typedef Ptr *		GCP;	/* Pointer to a garbage collected object */
! typedef unsigned	Page;	/* Page number */
  
  /*---------------------------------------------------------------------------*
   * -- Compatibility
--- 47,53 ----
  typedef unsigned long	Word;
  typedef char *		Ptr;
  typedef Ptr *		GCP;	/* Pointer to a garbage collected object */
! typedef unsigned	page;	/* Page number */
  
  /*---------------------------------------------------------------------------*
   * -- Compatibility
Only in /project/posso/cmm/curr/cmm: machine.h.orig
diff -c /home/omega/attardi/posso/cmm/msw.cpp /project/posso/cmm/curr/cmm/msw.cpp
*** /home/omega/attardi/posso/cmm/msw.cpp	Tue Jan  7 10:42:19 1997
--- /project/posso/cmm/curr/cmm/msw.cpp	Tue Feb 25 22:54:13 1997
***************
*** 1,6 ****
  /*****************************************************************************
   *
!  *  msw.cpp:	mark&sweep garbage collector for CMM.
   *
   *  version:    0.0.2 (30 Oct 96)
   *  authors:	Pietro Iglio
--- 1,6 ----
  /*****************************************************************************
   *
!  *  msw.cpp: memory manager with mark&sweep garbage collection.
   *
   *  version:    0.0.2 (30 Oct 96)
   *  authors:	Pietro Iglio
***************
*** 44,51 ****
   *	- MSW_CHECK_HEAP: perform automatic heap checking before/after every
   *                        collection and tempHeap destruction.
   *	- MSW_SERIAL_DEBUG
!  *	- MSW_TRACE_ONE_PAGE
!  *	- MSW_DONT_TAG_FREE_MEM: when NDEBUG is on avoid filling with a tag
   *	                         each empty/released memory object.
   *
   * Other macros that can be defined at compile time:
--- 44,51 ----
   *	- MSW_CHECK_HEAP: perform automatic heap checking before/after every
   *                        collection and tempHeap destruction.
   *	- MSW_SERIAL_DEBUG
!  * 	- MSW_TRACE_ONE_PAGE
!  *  	- MSW_DONT_TAG_FREE_MEM: when NDEBUG is on avoid filling with a tag
   *	                         each empty/released memory object.
   *
   * Other macros that can be defined at compile time:
***************
*** 196,201 ****
--- 196,202 ----
  #define TransparentMask		0xbb
  
  /* Page type: values for the page map */
+ #define PAGE_LONG_Free		0L
  
  #define PAGE_Free		0x0
  #define PAGE_Fixed		0x1
***************
*** 220,227 ****
   * If there is an attempt of using a free memory object, it should be easy to
   * understand if the mem obj has been released during a collection.
   */
! #define EMPTY_MEM_TAG		0xee
! #define RELEASED_MEM_TAG	0xdd
  
  #define PAGE_START(ptr)		(Ptr)((Word)(ptr) & ~(bytesPerPage - 1))
  
--- 221,228 ----
   * If there is an attempt of using a free memory object, it should be easy to
   * understand if the mem obj has been released during a collection.
   */
! #define EMPTY_MEM_TAG		0xdd
! #define RELEASED_MEM_TAG	0xee
  
  #define PAGE_START(ptr)		(Ptr)((Word)(ptr) & ~(bytesPerPage - 1))
  
***************
*** 255,262 ****
   */
  #define pageMap		pageLink
  
- // Max number of pages for a chunk (currently used for debugging only)
- #define MAX_CHUNK_PAGES          50000
  /*---------------------------------------------------------------------------*
   *
   * :: Type Definitions
--- 256,261 ----
***************
*** 430,441 ****
   *---------------------------------------------------------------------------*/
  
  
! static PageHeader     mswAllocFPage	       (Word size);
! static Ptr  	      mswAllocChunk	       (unsigned long, unsigned);
! static Ptr  	      mswAllocPages	       (int nPages, Word size);
  
! static Ptr            mswGetPages	       (int nPages, Word size);
! static PageHeader     mswSetupFPage	       (Ptr page, Word size);
  
  static void	      mswFreeChunk	       (PageHeader);
  
--- 429,440 ----
   *---------------------------------------------------------------------------*/
  
  
! static PageHeader     mswAllocFPage	     (Word size);
! static Ptr  	      mswAllocChunk	     (unsigned long, unsigned);
! static Ptr  	      mswAllocPages	     (int nPages, Word size);
  
! static Ptr            mswGetPages        (int nPages, Word size);
! static PageHeader     mswSetupFPage      (Ptr page, Word size);
  
  static void	      mswFreeChunk	       (PageHeader);
  
***************
*** 508,514 ****
  
  	freePage->allocatedObjs += 1;
  	*freeList = AllocMask;
! 	*(Byte *)(freeList-1) = TransparentMask;
  
  	// Following assignment is needed because subsequent call to
  	// mswAllocFPage might release completely "freePage".
--- 507,513 ----
  
  	freePage->allocatedObjs += 1;
  	*freeList = AllocMask;
! 	*(freeList-1) = TransparentMask;
  
  	// Following assignment is needed because subsequent call to
  	// mswAllocFPage might release completely "freePage".
***************
*** 544,550 ****
  {
  	if (size < MaxFixedSize) {
  	  Ptr ret = (Ptr)mswAlloc(size);
! 	  *(Byte *)(ret-2) = OpaqueMask;
  	  return ret;
  	}
  	else
--- 543,549 ----
  {
  	if (size < MaxFixedSize) {
  	  Ptr ret = (Ptr)mswAlloc(size);
! 	  *(ret-2) = OpaqueMask;
  	  return ret;
  	}
  	else
***************
*** 634,639 ****
--- 633,639 ----
  {
    Ptr            newPages;
  
+   mswDEBUG(fprintf(gcOut, "Automatic gc call...\n"););
    mswCollect();
  
    /* Expand anyway if not found enough free pages */
***************
*** 656,662 ****
      mswDEBUG(fprintf(gcOut, "Found enough pages after gc!\n"));
      return newPages;		/* <----------- */
    }
!   mswDEBUG(fprintf(gcOut, "[H]"));
  
    return mswExpandHeap(nPages);
  }
--- 656,663 ----
      mswDEBUG(fprintf(gcOut, "Found enough pages after gc!\n"));
      return newPages;		/* <----------- */
    }
!   mswDEBUG(fprintf(gcOut,
! 		   "Not found enough pages after gc! Expanding heap\n"));
  
    return mswExpandHeap(nPages);
  }
***************
*** 909,921 ****
  	PageHeader    page;
  
  	if (realSize >= size) {
! 		/* Size of mixed objects must be updated because during
! 		 * the mark phase we traverse only header->objSize bytes.
  		 */
! 		if (PAGE_INFO(p) == PAGE_Mixed) {
  			page = (PageHeader) PAGE_START(p);
  			page->objSize = size;
- 		      }
  		return p;	/* <---------- */
  	}
  	else {
--- 910,921 ----
  	PageHeader    page;
  
  	if (realSize >= size) {
! 		/* Size of mixed objects must be updated because during mark
! 		 * phase we traverse only header->objSize bytes.
  		 */
! 		if (PAGE_INFO(p) == PAGE_Mixed)
  			page = (PageHeader) PAGE_START(p);
  			page->objSize = size;
  		return p;	/* <---------- */
  	}
  	else {
***************
*** 946,952 ****
  void *
  mswCalloc(unsigned long n, unsigned long size)
  {
! 	void * mem = mswAlloc(n * size);
  
  	return memset(mem, 0, n * size);
  }
--- 946,952 ----
  void *
  mswCalloc(unsigned long n, unsigned long size)
  {
! 	Ptr	mem = (Ptr) mswAlloc(n * size);
  
  	return memset(mem, 0, n * size);
  }
***************
*** 1240,1248 ****
  mswMergeChunkWithNeighbors(Ptr chunk, int* pNPages)
  {
  	int nPages    = *pNPages;
! 	Page baseIndex = GCPtoPage(chunk);
! 	Page limitIndex= GCPtoPage(heapEnd);
! 	Page index     = baseIndex;
  	Ptr newChunk  = chunk;
  	FreePageHeader followChunk;
  
--- 1240,1248 ----
  mswMergeChunkWithNeighbors(Ptr chunk, int* pNPages)
  {
  	int nPages    = *pNPages;
! 	page baseIndex = GCPtoPage(chunk);
! 	page limitIndex= GCPtoPage(heapEnd);
! 	page index     = baseIndex;
  	Ptr newChunk  = chunk;
  	FreePageHeader followChunk;
  
***************
*** 1380,1387 ****
  {
  	int 	nPages = header->nPages;
  
- 	assert(nPages > 0 && nPages < MAX_CHUNK_PAGES);
- 
  	mswPageMapSet((Ptr)header, nPages, PAGE_Free);
  	assert(tempHeapInfo == NULL);
  //	if (tempHeapInfo)
--- 1380,1385 ----
***************
*** 1483,1489 ****
  	    assert(*(bp-1) == OpaqueMask ||
  		   *(bp-1) == TransparentMask);
  
! 	    if (*(Byte *)(bp-1) == OpaqueMask)
  	      continue;
  
  	    mswMarkFromTo((GCP)(bp+1),
--- 1481,1487 ----
  	    assert(*(bp-1) == OpaqueMask ||
  		   *(bp-1) == TransparentMask);
  
! 	    if (*(bp-1) == OpaqueMask)
  	      continue;
  
  	    mswMarkFromTo((GCP)(bp+1),
***************
*** 1560,1566 ****
        assert(*(bp-1) == OpaqueMask ||
  	     *(bp-1) == TransparentMask);
  		
!       if (*(Byte *)(bp-1) == OpaqueMask)
  	continue;
  		
        MarkStackPush((GCP)(bp+1));
--- 1558,1564 ----
        assert(*(bp-1) == OpaqueMask ||
  	     *(bp-1) == TransparentMask);
  		
!       if (*(bp-1) == OpaqueMask)
  	continue;
  		
        MarkStackPush((GCP)(bp+1));
***************
*** 1644,1650 ****
        assert(*(bp-1) == OpaqueMask ||
  	     *(bp-1) == TransparentMask);
  
!       if (*(Byte *)(bp-1) == OpaqueMask)
  	continue;
  
        MarkStackPush(pt+1);
--- 1642,1648 ----
        assert(*(bp-1) == OpaqueMask ||
  	     *(bp-1) == TransparentMask);
  
!       if (*(bp-1) == OpaqueMask)
  	continue;
  
        MarkStackPush(pt+1);
***************
*** 1955,1982 ****
    Word heapSize = (lastHeapPage - firstHeapPage) * bytesPerPage;
  
    if (heapSize < (Word)Cmm::gcThreshold)
!     ; // mswDEBUG(fprintf(gcOut, "heap size < gc threshold: skipping GC\n"));
    else {
!     mswDEBUG(fprintf(gcOut, "Calling GC...\n"););
      mswCollectNow();
    }
  }
  
  /*---------------------------------------------------------------------------*
   *
!  * :: MarkAndSweep()
   *
   *---------------------------------------------------------------------------*/
  
! MarkAndSweep::MarkAndSweep()
  {
  	extern  void	CmmInit(void);
  	int 	i, j, k;
  	Word	firstObjOff, bp = 0;
  	Word	lastObjOff;
  	Word    size1, counter;
  
! 	Cmm::theMSHeap = this;	// needed for allocatePages()
  
  	freeChunks = NULL;
  
--- 1953,1984 ----
    Word heapSize = (lastHeapPage - firstHeapPage) * bytesPerPage;
  
    if (heapSize < (Word)Cmm::gcThreshold)
!     mswDEBUG(fprintf(gcOut,
! 		     "heap size < gc threshold: skipping GC\n"));
    else {
!     mswDEBUG(fprintf(gcOut, "-> GC request ACCEPTED.\n"););
      mswCollectNow();
    }
  }
  
  /*---------------------------------------------------------------------------*
   *
!  * :: mswInit()
   *
   *---------------------------------------------------------------------------*/
  
! void
! mswInit()
  {
  	extern  void	CmmInit(void);
  	int 	i, j, k;
  	Word	firstObjOff, bp = 0;
  	Word	lastObjOff;
  	Word    size1, counter;
+ 	static  int initialized = 0;
  
! 	if (initialized) return;
! 	initialized = 1;
  
  	freeChunks = NULL;
  
***************
*** 2072,2078 ****
  static void	scanMixedPageRoots(PageHeader);
  
  void
! MarkAndSweep::scanRoots(Page page)
  {
  	unsigned pageInfo = PAGE_INFO(page);
  	PageHeader header = (PageHeader)pageToGCP(page);
--- 2074,2080 ----
  static void	scanMixedPageRoots(PageHeader);
  
  void
! MarkAndSweep::scanRoots(page page)
  {
  	unsigned pageInfo = PAGE_INFO(page);
  	PageHeader header = (PageHeader)pageToGCP(page);
***************
*** 2094,2100 ****
  
  	    for (ptr = (long*) obj + 1 + sizeof(Ptr);
  		 ptr < (long*) obj + 1 + size; ptr++)
! 	      promotePage((GCP)ptr);
  	  }
  	} else if (pageInfo == PAGE_Mixed) {
  	  long*	ptr;
--- 2096,2102 ----
  
  	    for (ptr = (long*) obj + 1 + sizeof(Ptr);
  		 ptr < (long*) obj + 1 + size; ptr++)
! 	      promotePage((GCP) ptr);
  	  }
  	} else if (pageInfo == PAGE_Mixed) {
  	  long*	ptr;
***************
*** 2105,2111 ****
  	  end = (long*) FirstObjOffset + 1 + header->objSize;
  	
  	  for (ptr = (long*) FirstObjOffset + 1; ptr < end; ptr++)
! 	    promotePage((GCP)ptr);
  	}
  }
  
--- 2107,2113 ----
  	  end = (long*) FirstObjOffset + 1 + header->objSize;
  	
  	  for (ptr = (long*) FirstObjOffset + 1; ptr < end; ptr++)
! 	    promotePage(ptr);
  	}
  }
  
***************
*** 2143,2149 ****
  static void
  mswTempHeapFreePages(void)
  {
! 	Page	page;
  	totReleasedPages = 0;
  
  	/* NOTE: the following loop is ugly because optimized */
--- 2145,2151 ----
  static void
  mswTempHeapFreePages(void)
  {
! 	page	page;
  	totReleasedPages = 0;
  
  	/* NOTE: the following loop is ugly because optimized */
***************
*** 2345,2351 ****
  	const int pagesPerLine = 72;
  
  	fprintf(gcOut,
! 		"+++++ (T = Temporary, - = Permanent) ++++");
  
  	for (i = base; i < top; i++) {
  	  if (j == 0) {
--- 2347,2353 ----
  	const int pagesPerLine = 72;
  
  	fprintf(gcOut,
! 		"+++++ (. = Free, # = Fixed, B/b = BigObj, O = Other) ++++");
  
  	for (i = base; i < top; i++) {
  	  if (j == 0) {
***************
*** 2602,2609 ****
  	firstObjOff = FPagesInfo[size].firstObjOffset;
  
  	for (p = page + firstObjOff; p <= hi; p += size1) {
! 	  assert(*(Byte *)(p-1) == TransparentMask
! 		 || *(Byte *)(p-1) == OpaqueMask);
  	  assert(*p == AllocMask || *p == FreeMask);
  	  if (*p == AllocMask)
  	    allocatedObjs += 1;
--- 2604,2610 ----
  	firstObjOff = FPagesInfo[size].firstObjOffset;
  
  	for (p = page + firstObjOff; p <= hi; p += size1) {
! 	  assert(*(p-1) == TransparentMask || *(p-1) == OpaqueMask);
  	  assert(*p == AllocMask || *p == FreeMask);
  	  if (*p == AllocMask)
  	    allocatedObjs += 1;
***************
*** 2822,2852 ****
  	  base = GET_OBJ_BASE(p, page);
  	  fprintf(gcOut, "pointer base: %lx\n", base);
  	  if (base == p) {
! 	    fprintf(gcOut, "WARNING: the pointer points before the beginning of a fixed object!\n");
  	    return;
  	  }
- 	  switch (*base) {
- 	  case AllocMask:
- 	    fprintf(gcOut, "STATE: allocated\n"); break;
- 	  case MarkMask:
- 	    fprintf(gcOut, "STATE: marked\n"); break;
- 	  case FreeMask:
- 	    fprintf(gcOut, "STATE: free\n"); break;
- 	  default:
- 	    fprintf(gcOut,
- 		    "WARNING: STATE is not MarkMask | AllocMask | FreeMask! \n");
- 	    break;
- 	  }
- 	  switch (*(base-1)) {
- 	  case OpaqueMask:
- 	    fprintf(gcOut, "Obj is OPAQUE \n"); break;
- 	  case TransparentMask:
- 	    fprintf(gcOut, "Obj is TRANSPARENT \n"); break;
- 	  default:
- 	    fprintf(gcOut,
- 		    "WARNING: not registred as OPAQUE or TRANSPARENT! \n");
- 	    break;
- 	  }
  	  break;
  	case PAGE_Next: {
  	  int index;
--- 2823,2831 ----
  	  base = GET_OBJ_BASE(p, page);
  	  fprintf(gcOut, "pointer base: %lx\n", base);
  	  if (base == p) {
! 	    fprintf(gcOut, "WARNING: the pointer points before the start of the object!\n");
  	    return;
  	  }
  	  break;
  	case PAGE_Next: {
  	  int index;
***************
*** 2864,2870 ****
  	    index -= 1;
  	    assert(index > 0);
  	  }
! 	  p = (Ptr)pageToGCP(index);
  	  goto LAB_PageMixed;
  	}
  	case PAGE_Mixed:
--- 2843,2849 ----
  	    index -= 1;
  	    assert(index > 0);
  	  }
! 	  p = pageToGCP(index);
  	  goto LAB_PageMixed;
  	}
  	case PAGE_Mixed:
***************
*** 2936,2942 ****
  Ptr
  pageFromIndex(int index)
  {
! 	return (Ptr)pageToGCP(index);
  }
  
  int
--- 2915,2921 ----
  Ptr
  pageFromIndex(int index)
  {
! 	return pageToGCP(index);
  }
  
  int
Only in /project/posso/cmm/curr/cmm: msw.cpp.orig
diff -c /home/omega/attardi/posso/cmm/msw.h /project/posso/cmm/curr/cmm/msw.h
*** /home/omega/attardi/posso/cmm/msw.h	Tue Jan  7 10:42:50 1997
--- /project/posso/cmm/curr/cmm/msw.h	Tue Feb 25 22:54:13 1997
***************
*** 1,10 ****
  /*---------------------------------------------------------------------------*
   *
!  *  msw.h:	mark&sweep garbage collector for CMM.
   *
   *  date:	6 March 1995
   *  authors:	Pietro Iglio
!  *  email:	cmm@di.unipi.it, iglio@di.unipi.it
   *  address:	Dipartimento di Informatica
   *		Corso Italia 40
   *		I-56125 Pisa, Italy
--- 1,10 ----
  /*---------------------------------------------------------------------------*
   *
!  *  msw.h:	memory manager with mark&sweep garbage collection.
   *
   *  date:	6 March 1995
   *  authors:	Pietro Iglio
!  *  email:	cmm@di.unipi.it, iglio@posso.dm.unipi.it
   *  address:	Dipartimento di Informatica
   *		Corso Italia 40
   *		I-56125 Pisa, Italy
Only in /project/posso/cmm/curr/cmm: msw.h.orig
diff -c /home/omega/attardi/posso/cmm/tempheap.cpp /project/posso/cmm/curr/cmm/tempheap.cpp
*** /home/omega/attardi/posso/cmm/tempheap.cpp	Mon Dec 23 11:35:50 1996
--- /project/posso/cmm/curr/cmm/tempheap.cpp	Tue Feb 25 22:54:14 1997
***************
*** 66,72 ****
    bzero((char*)&objectMap[WORD_INDEX(body)],
  	((usedWords() + bitsPerWord - 1) / bitsPerWord) * bytesPerWord);
  #if !HEADER_SIZE || defined(MARKING)
!   resetliveMap();
  #endif
    top = BOTTOM;
  }
--- 66,73 ----
    bzero((char*)&objectMap[WORD_INDEX(body)],
  	((usedWords() + bitsPerWord - 1) / bitsPerWord) * bytesPerWord);
  #if !HEADER_SIZE || defined(MARKING)
!   bzero((char*)&liveMap[WORD_INDEX(body)],
! 	((usedWords() + bitsPerWord - 1) / bitsPerWord) * bytesPerWord);
  #endif
    top = BOTTOM;
  }
***************
*** 144,163 ****
  
  RootSet::RootSet()
  {
!   // Default to non conservative
    isConservative = false;
  }
  
  void
  RootSet::scan(CmmHeap *heap)
  {
!   CmmObject *objPtr, **objPtrLoc;
    CmmHeap *oldHeap = Cmm::heap;
    Cmm::heap = heap;
!   roots.begin();
!   while (objPtr = roots.get()) objPtr->traverse();
!   rootsLoc.begin();
!   while (objPtrLoc = rootsLoc.get()) heap->scavenge(objPtrLoc);
    Cmm::heap = oldHeap;
  }
  
--- 145,282 ----
  
  RootSet::RootSet()
  {
!   entryInc = 10;
!   entryNum = 10;
!   current = 0;
!   entrypNum = 10;
!   currentp = 0;
! 
!   // Default to not-conservative
    isConservative = false;
+ 
+   entry = new CmmObject*[entryNum];
+   entryp = new CmmObject**[entrypNum];
+ 
+   int i;
+   for (i = 0; i < entryNum; i++)
+     entry[i] = NULL;
+   for (i = 0; i < entrypNum; i++)
+     entryp[i] = NULL;
+ 
+ }
+ 
+ void 
+ RootSet::set(CmmObject *obj)
+      // trivial implementation, but this is not a critical operation
+ {
+   int i;
+   for (i = 0; i < entryNum; i++)
+     if (entry[i] == NULL)
+       {
+ 	entry[i] = obj;
+ 	return;
+       }
+   CmmObject **tmp = new CmmObject*[entryNum + entryInc];
+ 
+   for (i = 0; i < entryNum; i++)
+     tmp[i] = entry[i];
+   delete entry;
+   entry = tmp;
+   entry[i++] = obj;
+   entryNum += entryInc;
+   // put the rest to NULL.
+   for (; i < entryNum; i++)
+     entry[i] = NULL;
+ }
+ 
+ void 
+ RootSet::unset(CmmObject *obj)
+ {
+   int i;
+   for (i = 0; ((i < entryNum) && (entry[i] != obj)); i++);
+   assert (entry[i] == obj);
+   entry[i] = NULL;
+ }
+ 
+ CmmObject *
+ RootSet::get()
+ {
+   // look for a not empty entry
+   while (current < entryNum)
+     {
+       if (entry[current])
+ 	return entry[current++];
+       else
+ 	current++;
+     }
+   // No more entries;
+   return (CmmObject *)NULL;
+ }
+ 
+ void
+ RootSet::setp(CmmObject **obj)
+      // trivial implementation, but this is not a critical operation
+ {
+   int i;
+   for (i = 0; i < entrypNum; i++)
+     if (entryp[i] == NULL)
+       {
+ 	entryp[i] = obj;
+ 	return;
+       }
+   CmmObject ***tmp = new CmmObject**[entrypNum + entryInc];
+ 
+   for (i = 0; i < entrypNum; i++)
+     tmp[i] = entryp[i];
+   delete entryp;
+   entryp = tmp;
+   entryp[i++] = obj;
+   entrypNum += entryInc;
+   // put the rest to NULL.
+   for (; i < entrypNum; i++)
+     entryp[i] = NULL;
+ }
+ 
+ void
+ RootSet::unsetp(CmmObject **obj)
+ {
+   int i;
+   for (i = 0; ((i < entrypNum) && (entryp[i] != obj)); i++);
+   assert (entryp[i] == obj);
+   entryp[i] = NULL;
+ }
+ 
+ CmmObject **
+ RootSet::getp()
+ {
+   // look for a not empty entry
+   while (currentp < entrypNum)
+     {
+       if (entryp[currentp])
+ 	return entryp[currentp++];
+       else
+ 	currentp++;
+     }
+   // No more entries;
+   return (CmmObject **)NULL;
+ }
+ 
+ void
+ RootSet::reset()
+ {
+   current = 0;
+   currentp = 0;
  }
  
  void
  RootSet::scan(CmmHeap *heap)
  {
!   reset();
!   CmmObject *objPtr, **objPtrPtr;
    CmmHeap *oldHeap = Cmm::heap;
    Cmm::heap = heap;
!   while (objPtr = get()) objPtr->traverse();
!   while (objPtrPtr = getp()) heap->scavenge(objPtrPtr);
    Cmm::heap = oldHeap;
  }
  
Only in /project/posso/cmm/curr/cmm: tempheap.cpp.orig
diff -c /home/omega/attardi/posso/cmm/tempheap.h /project/posso/cmm/curr/cmm/tempheap.h
*** /home/omega/attardi/posso/cmm/tempheap.h	Mon Dec 23 12:28:05 1996
--- /project/posso/cmm/curr/cmm/tempheap.h	Tue Feb 25 22:54:14 1997
***************
*** 88,94 ****
    int top;			// index to the first free word
  };
  
- 
  /*---------------------------------------------------------------------------*
   *
   * -- RootSet
--- 88,93 ----
***************
*** 99,124 ****
  {
  private:
    bool isConservative;
!   void scanSystemRoots() {}; // Still to define
  
  public:
!   RootSet();
!   void insert(CmmObject* p) { roots.insert(p); }
!   void insert(CmmObject** p){ rootsLoc.insert(p); }
!   void erase(CmmObject* p)  { roots.erase(p); }
!   void erase(CmmObject** p) { rootsLoc.erase(p); }
    void scan(CmmHeap *);
    
!   // back compatibility
!   void set(CmmObject* p)    { roots.insert(p); }
!   void setp(CmmObject** p)  { rootsLoc.insert(p); }
!   void unset(CmmObject* p)  { roots.erase(p); }
!   void unsetp(CmmObject** p){ rootsLoc.erase(p); }
!   
  private:
!   
!   Set<CmmObject>  roots;
!   Set<CmmObject*> rootsLoc;
  };
  
  
--- 98,127 ----
  {
  private:
    bool isConservative;
!   void scanSystemRoots() {};	// Still to define
  
  public:
!   void set(CmmObject *);
!   void unset(CmmObject *);
!   CmmObject *get();
!   void setp(CmmObject **);
!   void unsetp(CmmObject **);
!   CmmObject **getp();
!   void reset();
! 
    void scan(CmmHeap *);
    
!   RootSet();
! 
  private:
!   int entryInc;			// = 10;
!   int entryNum;			// = 10;
!   int current;			// = 0;
!   int entrypNum;		// = 10;
!   int currentp;			// = 0;
! 
!   CmmObject **entry;
!   CmmObject ***entryp;
  };
  
  
***************
*** 132,151 ****
  
  class TempHeap : public CmmHeap 
  {
!   
  public:
!   
    void scavenge(CmmObject **);
    void collect();
    void reset();
    void weakReset();
!   
    TempHeap(int bytes = 100000) {
!     
      current = 0;
      toCollect = false;
      chunkInc = 4;
!     
      chunkNum = chunkInc;
      chunkSize = bytes;
      // Can you use expand here?
--- 135,154 ----
  
  class TempHeap : public CmmHeap 
  {
! 
  public:
! 
    void scavenge(CmmObject **);
    void collect();
    void reset();
    void weakReset();
! 
    TempHeap(int bytes = 100000) {
! 
      current = 0;
      toCollect = false;
      chunkInc = 4;
!       
      chunkNum = chunkInc;
      chunkSize = bytes;
      // Can you use expand here?
***************
*** 155,161 ****
    }
    
    RootSet roots;
!   
  private: 
    
    bool toCollect;
--- 158,164 ----
    }
    
    RootSet roots;
! 
  private: 
    
    bool toCollect;
***************
*** 166,172 ****
    Container **chunk;
    
    CmmObject *copy(CmmObject *);
!   
    GCP alloc(unsigned long);
    
    Container *inside(CmmObject *ptr) {
--- 169,175 ----
    Container **chunk;
    
    CmmObject *copy(CmmObject *);
! 
    GCP alloc(unsigned long);
    
    Container *inside(CmmObject *ptr) {
***************
*** 181,185 ****
    void expand();
  };
  
! #endif				// _tempheap_h
  /* DON'T ADD STUFF AFTER THIS #endif */
--- 184,188 ----
    void expand();
  };
  
! #endif // _tempheap_h
  /* DON'T ADD STUFF AFTER THIS #endif */
Only in /project/posso/cmm/curr/cmm: tempheap.h.orig
diff -c /home/omega/attardi/posso/cmm/test2.cpp /project/posso/cmm/curr/cmm/test2.cpp
*** /home/omega/attardi/posso/cmm/test2.cpp	Tue Dec 17 11:37:30 1996
--- /project/posso/cmm/curr/cmm/test2.cpp	Tue Feb 25 22:48:25 1997
***************
*** 79,84 ****
  	    abort();
  	  }
  	  cl = cl->next;
! 	}
  	return 0;
  }
--- 79,84 ----
  	    abort();
  	  }
  	  cl = cl->next;
! 	}
  	return 0;
  }
Only in /project/posso/cmm/curr/cmm: test2.cpp.orig
diff -c /home/omega/attardi/posso/cmm/test3.cpp /project/posso/cmm/curr/cmm/test3.cpp
*** /home/omega/attardi/posso/cmm/test3.cpp	Tue Dec 17 11:37:45 1996
--- /project/posso/cmm/curr/cmm/test3.cpp	Tue Feb 25 22:48:25 1997
***************
*** 42,48 ****
  	    0, 1, CMM_GCTHRESHOLD, CMM_FLAGS, 0);
  }
  
! void
  main(int argc, char* argv[])
  {
  	block  *lp = NULL;
--- 42,48 ----
  	    0, 1, CMM_GCTHRESHOLD, CMM_FLAGS, 0);
  }
  
! void
  main(int argc, char* argv[])
  {
  	block  *lp = NULL;
Only in /project/posso/cmm/curr/cmm: test3.cpp.orig
diff -c /home/omega/attardi/posso/cmm/test4.cpp /project/posso/cmm/curr/cmm/test4.cpp
*** /home/omega/attardi/posso/cmm/test4.cpp	Sat Dec  7 07:03:28 1996
--- /project/posso/cmm/curr/cmm/test4.cpp	Tue Feb 25 22:47:15 1997
***************
*** 61,67 ****
  
  Cmm dummy(CMM_MINHEAP, CMM_MAXHEAP, CMM_INCHEAP, 50, 45,
  	  CMM_GCTHRESHOLD, CMM_FLAGS, 0);
! 
  void
  main()
  {
--- 61,67 ----
  
  Cmm dummy(CMM_MINHEAP, CMM_MAXHEAP, CMM_INCHEAP, 50, 45,
  	  CMM_GCTHRESHOLD, CMM_FLAGS, 0);
! 
  void
  main()
  {
Only in /project/posso/cmm/curr/cmm: test4.cpp.orig
diff -c /home/omega/attardi/posso/cmm/test5.cpp /project/posso/cmm/curr/cmm/test5.cpp
*** /home/omega/attardi/posso/cmm/test5.cpp	Thu Jan  9 11:07:13 1997
--- /project/posso/cmm/curr/cmm/test5.cpp	Tue Feb 25 23:00:48 1997
***************
*** 1,10 ****
! /* Test program for CMM */
  
  /* Externals */
  
  #include <stdio.h>
  #include <stdlib.h>
! #include "cmm.h"
  
  struct  cell : CmmObject 
  {
--- 1,10 ----
! /* Test program for the gcalloc.c */
  
  /* Externals */
  
  #include <stdio.h>
  #include <stdlib.h>
! #include "tempheap.h"
  
  struct  cell : CmmObject 
  {
***************
*** 195,200 ****
--- 195,201 ----
  void
  main()
  {
+ //  Cmm::heap = new TempHeap(10000);
    /* List construction test */
    listtest1();
  
Only in /project/posso/cmm/curr/cmm: test5.cpp.orig
diff -c /home/omega/attardi/posso/cmm/test7.cpp /project/posso/cmm/curr/cmm/test7.cpp
*** /home/omega/attardi/posso/cmm/test7.cpp	Thu Jan  9 09:00:04 1997
--- /project/posso/cmm/curr/cmm/test7.cpp	Tue Feb 25 23:00:48 1997
***************
*** 9,15 ****
  
  int count = 0;
  
! class Item : public CmmObject
  {
  public:
    Item  *car;
--- 9,15 ----
  
  int count = 0;
  
! class Item : public CmmObject 
  {
  public:
    Item  *car;
***************
*** 44,50 ****
  void*
  Item::operator new[](size_t size)
  {
!   return sizeof(size_t) + (char*)new(size) CmmArray<Item>;
  }
  
  void
--- 44,50 ----
  void*
  Item::operator new[](size_t size)
  {
!   return sizeof(CmmObject) + (char*)new(size) CmmArray<Item>;
  }
  
  void
***************
*** 61,74 ****
  	printf("%d ", i);
        else
  	printf("%d\n", i);
!       zp = new Item[8];
!       zp[0] = Item(NULL, lp, i, i);
        lp = zp;
        Cmm::heap->collect();
        zp = lp;
        for (j = i; j >= 0 ; j--)  
  	{
! 	  if ((zp == NULL) || (zp[0].value1 != j)  ||  (zp[0].value2 != j))
  	    printf("LP is not a good list when j = %d\n", j);
  	  zp = zp->cdr;
  	}
--- 61,73 ----
  	printf("%d ", i);
        else
  	printf("%d\n", i);
!       zp = new vector[10](NULL, lp, i, i);
        lp = zp;
        Cmm::heap->collect();
        zp = lp;
        for (j = i; j >= 0 ; j--)  
  	{
! 	  if ((zp == NULL) || (zp->value1 != j)  ||  (zp->value2 != j))
  	    printf("LP is not a good list when j = %d\n", j);
  	  zp = zp->cdr;
  	}
***************
*** 76,86 ****
    printf("\n");		   
  }
  
! void
  main()
  {
!   /* List of Items > 1 page */
!   test();
  
    exit(0);
  }
--- 75,85 ----
    printf("\n");		   
  }
  
! void
  main()
  {
!   /* List of vectors > 1 page */
!   vectortest();
  
    exit(0);
  }
Only in /project/posso/cmm/curr/cmm: test7.cpp.orig
Only in /project/posso/cmm/curr/cmm: test7.cpp.rej
